<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[组合计数]]></title>
      <url>/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0.html</url>
      <content type="html"><![CDATA[<h1 id="计数原理"><a href="#计数原理" class="headerlink" title="计数原理"></a>计数原理</h1><p><br></p>
<div class="note info"><p><strong>加法原理:</strong>做一件事情有$n$个办法，第$i$个办法有$p_i$种方案，则一共有$p_1+p_2+…+p_n$种方案</p>
<p><strong>乘法原理:</strong>做一件事情有$n$个步骤，第$i$个步骤有$p_i$种方案，则一共有$p_1 \times p_2 \times … \times p_n$种方案</p></div>
<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>先不考虑重叠的情况，计算出所有对象的数目，再把计数时重复计算的数目排斥出去</p>
<h2 id="鸽巢原理"><a href="#鸽巢原理" class="headerlink" title="鸽巢原理"></a>鸽巢原理</h2><p>把$n+1$个小球放进$n$个盒子，至少有一个盒子包含至少两个小球</p>
<p>一般形式：把$m$个小球放进$n$个盒子，至少有一个盒子包含至少$⌈m/n⌉$个小球</p>
<span class="label success">最差原则：考虑所有可能情况中，最不利于某件事情发生的情况</span>
<h2 id="Ramsey定理"><a href="#Ramsey定理" class="headerlink" title="Ramsey定理"></a>Ramsey定理</h2><p>将$6$个顶点的完全图的边用红、蓝两色任意着色，至少存在一个红色边三角形或蓝色边三角形</p>
<p><br></p>
<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><p><br></p>
<h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>$n$个不同的数，选$k$个排成一排，每个数最多选一次</p>
<p>由乘法原理，$P(n,k)=\frac{n!}{(n-k)!}$</p>
<p>特别地，定义$0!=1$，$n$个数的全排列数$P(n,n)=n!$</p>
<h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>$n$个不同的数，选$k$个(顺序无关)，每个数最多选一次</p>
<p>把$n$选$k$的排列问题分成两个步骤：</p>
<p>首先选出$k$个数的组合，然后把这$k$个数进行全排列</p>
<p>$C(n,k)=\frac{P(n,k)}{P(k,k)}=\frac{n!}{(n-k)!k!}$</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><div class="note success"><ol>
<li>$C(n,0)=C(n,n)=1$</li>
<li>$C(n,k)=C(n,n-k)$，$n$选$k$和$n$不选$k$的方案一一对应</li>
<li>$C(n,k)=C(n-1,k)+C(n-1,k-1)$，组合数递推公式，由加法原理推导出</li>
<li>二项式定理：$(a+b)^n=\sum\limits_{k=0}^{n} _{}^{}$</li>
</ol>
<p>note danger, note danger, note danger<br>note danger, note danger, note danger</p></div>
<h1 id="一些计数问题"><a href="#一些计数问题" class="headerlink" title="一些计数问题"></a>一些计数问题</h1><h1 id="等价类计数"><a href="#等价类计数" class="headerlink" title="等价类计数"></a>等价类计数</h1><h2 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h2><p>群论</p>
<p><a href="http://blog.csdn.net/xym_CSDN/article/details/53456447" target="_blank" rel="noopener">http://blog.csdn.net/xym_CSDN/article/details/53456447</a></p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 组合计数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[高精度]]></title>
      <url>/%E9%AB%98%E7%B2%BE%E5%BA%A6.html</url>
      <content type="html"><![CDATA[<p>业界毒瘤<br>python大法好(雾</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rad 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 4<span class="comment">//int压4位</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bi</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2005</span>],l;</span><br><span class="line">    Bi()&#123;<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));l=<span class="number">1</span>;&#125;<span class="comment">//这里的memset可能会T……</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bi <span class="keyword">operator</span> + (Bi a,Bi b)&#123;</span><br><span class="line">    a.l=a.l&gt;b.l?a.l:b.l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a.l;i++)&#123;  </span><br><span class="line">    	a.s[i]+=b.s[i];</span><br><span class="line">    	<span class="keyword">if</span>(a.s[i]&gt;=rad) a.s[i]-=rad,a.s[i+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.s[a.l+<span class="number">1</span>]) a.l++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bi <span class="keyword">operator</span> - (Bi a,Bi b)&#123;<span class="comment">//大减小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a.l;i++)&#123;</span><br><span class="line">        a.s[i]-=b.s[i];</span><br><span class="line">        <span class="keyword">if</span>(a.s[i]&lt;<span class="number">0</span>) a.s[i]+=rad,a.s[i+<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a.l&gt;<span class="number">1</span>&amp;&amp;!a.s[a.l]) a.l--;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bi <span class="keyword">operator</span> * (Bi a,Bi b)&#123;<span class="comment">//暴力</span></span><br><span class="line">    Bi c;c.l=a.l+b.l<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a.l;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b.l;j++)</span><br><span class="line">            c.s[i+j<span class="number">-1</span>]+=a.s[i]*b.s[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c.l;i++)&#123;</span><br><span class="line">        c.s[i+<span class="number">1</span>]+=c.s[i]/rad;</span><br><span class="line">        c.s[i]%=rad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c.s[c.l+<span class="number">1</span>]) c.l++;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bi <span class="keyword">operator</span> / (Bi a,<span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    Bi c;c.l=a.l;<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.l;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        k=k*rad+a.s[i];</span><br><span class="line">        c.s[i]=k/b;k%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.l&gt;<span class="number">1</span>&amp;&amp;!c.s[c.l]) c.l--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Bi x,Bi y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.l!=y.l) <span class="keyword">return</span> x.l&lt;y.l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x.l;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(x.s[i]!=y.s[i]) <span class="keyword">return</span> x.s[i]&lt;y.s[i];  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(Bi &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">strlen</span>(d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">        j=(l-i+B)/B,x.s[j]=x.s[j]*<span class="number">10</span>+d[i]-<span class="string">'0'</span>;</span><br><span class="line">    x.l=(l<span class="number">-1</span>+B)/B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Bi a)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,a.s[a.l]);<span class="keyword">for</span>(<span class="keyword">int</span> i=a.l<span class="number">-1</span>;i;i--) <span class="built_in">printf</span>(<span class="string">"%04d"</span>,a.s[i]);&#125;<span class="comment">//补0输出</span></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础算法 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[平衡树]]></title>
      <url>/%E5%B9%B3%E8%A1%A1%E6%A0%91.html</url>
      <content type="html"><![CDATA[<h1 id="sbt"><a href="#sbt" class="headerlink" title="sbt"></a>sbt</h1><div class="note info"><p>依靠size域维持平衡，对任意结点$x$满足<br>$size[rs[x]] \geq size[ls[ls[x]]],size[rs[ls[x]]]$<br>$size[ls[x]] \geq size[rs[rs[x]]],size[ls[rs[x]]]$</p></div>
<a id="more"></a>
<p><br></p>
<p>安利退化版sbt，<a href="https://wenku.baidu.com/view/5f94ff22192e45361066f5b1.html" target="_blank" rel="noopener">a short introduce</a><br>可能被卡（应该不会有人卡这个吧……）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种操作，与普通二叉查找树区别不大……</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> son(x,y) c[c[x][y]][y]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;sz[x]=sz[c[x][<span class="number">0</span>]]+sz[c[x][<span class="number">1</span>]]+<span class="number">1</span>;sum[x]=sum[c[x][<span class="number">0</span>]]+sum[c[x][<span class="number">1</span>]]+k[x];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> v)</span></span>&#123;x=++top,c[x][<span class="number">0</span>]=c[x][<span class="number">1</span>]=<span class="number">0</span>,sz[x]=<span class="number">1</span>,k[x]=v;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=c[x][k^<span class="number">1</span>];</span><br><span class="line">    c[x][k^<span class="number">1</span>]=c[y][k];</span><br><span class="line">    c[y][k]=x;pushup(y);</span><br><span class="line">    pushup(x);x=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) node(x,v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> m=v&gt;=k[x];<span class="comment">//这里把相同元素插入x的右子树 </span></span><br><span class="line">        insert(c[x][m],v);</span><br><span class="line">        <span class="keyword">if</span>(sz[son(x,m)]&gt;sz[c[x][m^<span class="number">1</span>]])<span class="comment">//维护平衡 </span></span><br><span class="line">        rotate(x,m^<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> y;  </span><br><span class="line">    <span class="keyword">if</span>(v&gt;k[x]) <span class="keyword">return</span> pre(c[x][<span class="number">1</span>],x,v);  </span><br><span class="line">    <span class="keyword">return</span> pre(c[x][<span class="number">0</span>],y,v);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> y;  </span><br><span class="line">    <span class="keyword">if</span>(v&lt;k[x]) <span class="keyword">return</span> suc(c[x][<span class="number">0</span>],x,v);  </span><br><span class="line">    <span class="keyword">return</span> suc(c[x][<span class="number">1</span>],y,v);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rk</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span><span class="comment">//求权值为x的排名 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v&gt;k[x]) <span class="keyword">return</span> sz[c[x][<span class="number">0</span>]]+<span class="number">1</span>+rk(c[x][<span class="number">1</span>],v);</span><br><span class="line">    <span class="keyword">return</span> rk(c[x][<span class="number">0</span>],v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=sz[c[x][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(w&lt;r) <span class="keyword">return</span> select(c[x][<span class="number">0</span>],w);</span><br><span class="line">    <span class="keyword">if</span>(w&gt;r) <span class="keyword">return</span> select(c[x][<span class="number">1</span>],w-r);</span><br><span class="line">    <span class="keyword">return</span> k[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> ;sz[x]--;sum[x]-=v;</span><br><span class="line">    <span class="keyword">if</span>(k[x]!=v) del(c[x][v&gt;k[x]],v);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l=c[x][<span class="number">0</span>],r=c[x][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(!l||!r) x=l+r;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(c[r][<span class="number">0</span>]) r=c[r][<span class="number">0</span>];<span class="comment">//乱搞删除</span></span><br><span class="line">            k[x]=k[r];</span><br><span class="line">            del(c[x][<span class="number">1</span>],k[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>,top=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="splay"><a href="#splay" class="headerlink" title="splay"></a>splay</h1><div class="note info"><p>依靠伸展操作维护平衡，复杂度可以势能分析证明<br>使被查询频率高的节点更靠近树根<br>常数巨大</p></div>
<p><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LCT</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> c[fa[x]][<span class="number">1</span>]==x;&#125;<span class="comment">//指示方向</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isr</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> c[fa[x]][<span class="number">0</span>]!=x&amp;&amp;c[fa[x]][<span class="number">1</span>]!=x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> &amp;l=c[x][<span class="number">0</span>],&amp;r=c[x][<span class="number">1</span>];</span><br><span class="line">    rev[l]^=<span class="number">1</span>;rev[r]^=<span class="number">1</span>;swap(l,r);</span><br><span class="line">    rev[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=fa[x],g=fa[p],r;</span><br><span class="line">    <span class="keyword">bool</span> k=f(x),m=f(p);r=c[x][k^<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!isr(p)) c[g][m]=x;<span class="comment">//自上而下重新连接</span></span><br><span class="line">    fa[x]=g,c[x][k^<span class="number">1</span>]=p;</span><br><span class="line">    fa[p]=x,c[p][k]=r;</span><br><span class="line">    <span class="keyword">if</span>(r) fa[r]=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>;st[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;!isr(i);i=fa[i]) st[++top]=fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i;i--) pushdown(st[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    maintain(x);</span><br><span class="line">    <span class="keyword">for</span>(;!isr(x);rotate(x))</span><br><span class="line">     	<span class="keyword">if</span>(!isr(fa[x])) rotate(f(x)==f(fa[x])?fa[x]:x);<span class="comment">//理性理解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="fhq-treap"><a href="#fhq-treap" class="headerlink" title="fhq treap"></a>fhq treap</h1><div class="note info"><p>每个结点有一个附加权，满足堆的性质<br>随机生产附加权，达到期望平衡<br>非旋转，可持久化</p></div>
<p><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    pushdown(x);pushdown(y);</span><br><span class="line">    <span class="keyword">if</span>(rk[x]&lt;rk[y])</span><br><span class="line">    &#123;</span><br><span class="line">        c[x][<span class="number">1</span>]=merge(c[x][<span class="number">1</span>],y);</span><br><span class="line">        pushup(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c[y][<span class="number">0</span>]=merge(x,c[y][<span class="number">0</span>]);</span><br><span class="line">        pushup(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span><span class="comment">//按前k个分裂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) x=y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pushdown(now);</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=size[c[now][<span class="number">0</span>]])</span><br><span class="line">            y=now,split(c[now][<span class="number">0</span>],k,x,c[now][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x=now,split(c[now][<span class="number">1</span>],k-size[c[now][<span class="number">0</span>]]<span class="number">-1</span>,c[now][<span class="number">1</span>],y);</span><br><span class="line">        pushup(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://memphis.is-programmer.com/posts/46317.html" target="_blank" rel="noopener">link1</a><br><a href="http://www.yhzq-blog.cc/fhq-treap总结/" target="_blank" rel="noopener">link2</a></p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STL容器]]></title>
      <url>/STL%E5%AE%B9%E5%99%A8.html</url>
      <content type="html"><![CDATA[<div class="note warning"><ol>
<li>常数巨大(without O2)</li>
<li>动态内存,unfriendly for cena</li>
</ol></div>
<a id="more"></a>
<p><br></p>
<h1 id="queue-stack-priority-queue"><a href="#queue-stack-priority-queue" class="headerlink" title="queue/stack/priority_queue"></a>queue/stack/priority_queue</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">queue</span>/<span class="built_in">stack</span>&gt;</span><br><span class="line">定义:<span class="built_in">queue</span>&lt;data&gt; x;</span><br><span class="line">小根堆:priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.push(key) x.pop(key)</span><br><span class="line">x.front() x.top()</span><br><span class="line">x.size() x.empty()</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;iostream&gt;</span><br><span class="line">定义:pair&lt;data,data&gt; x;</span><br></pre></td></tr></table></figure>
<h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.first .second<span class="comment">//访问</span></span><br><span class="line">make_pair(x,y)<span class="comment">//构造</span></span><br><span class="line">重载了&lt;，以first为第一关键字，second为第二关键字升序</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="set-multiset-hash-set-unordered-set"><a href="#set-multiset-hash-set-unordered-set" class="headerlink" title="set/multiset/hash_set/unordered_set"></a>set/multiset/hash_set/unordered_set</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">set</span>/<span class="built_in">unordered_set</span>&gt;<span class="comment">//unordered_set was defined in C++11</span></span><br><span class="line">定义:<span class="built_in">set</span>&lt;data&gt; x;</span><br><span class="line">迭代器:<span class="built_in">set</span>&lt;data&gt;::iterator it;</span><br></pre></td></tr></table></figure>
<h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x.clear()</span><br><span class="line">x.insert(key)<span class="comment">//插入一个值key</span></span><br><span class="line">x.erase(key)<span class="comment">//删除键值为key的元素(multiset会全部删除)</span></span><br><span class="line">x.erase(it)<span class="comment">//删除迭代器为it的元素</span></span><br><span class="line">x.erase(l,r)<span class="comment">//删除地址[l,r)的元素,l,r为两个迭代器指针</span></span><br><span class="line">x.begin() x.end()</span><br><span class="line">x.size() x.empty()</span><br><span class="line">x.find(key)<span class="comment">//返回key的迭代器指针</span></span><br><span class="line">x.count(key)<span class="comment">//返回键值等于key的元素的个数(multiset中使用)</span></span><br><span class="line">x.lower_bound(key)</span><br><span class="line">x.upper_bound(key)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="map-multimap-hash-map-unordered-map"><a href="#map-multimap-hash-map-unordered-map" class="headerlink" title="map/multimap/hash_map/unordered_map"></a>map/multimap/hash_map/unordered_map</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">map</span>/<span class="built_in">unordered_map</span>&gt;<span class="comment">//unordered_map was defined in C++11</span></span><br><span class="line">定义:<span class="built_in">map</span>&lt;data&gt; x;</span><br><span class="line">迭代器:<span class="built_in">map</span>&lt;data&gt;::iterator it;</span><br></pre></td></tr></table></figure>
<h2 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x.clear()</span><br><span class="line">mp[x]=key<span class="comment">//插入元素</span></span><br><span class="line">it-&gt;first it-&gt;second<span class="comment">//迭代器访问</span></span><br><span class="line">x.erase(key)<span class="comment">//删除键值为key的元素(multimap会全部删除)</span></span><br><span class="line">x.erase(it)<span class="comment">//删除迭代器为it的元素</span></span><br><span class="line">x.erase(l,r)<span class="comment">//删除地址[l,r)的元素,l,r为两个迭代器指针</span></span><br><span class="line">x.swap(x2)<span class="comment">//交换x,x2</span></span><br><span class="line">x.begin() x.end()</span><br><span class="line">x.size() x.empty()</span><br><span class="line">x.find(key)<span class="comment">//返回key的迭代器指针</span></span><br><span class="line">x.count(key)<span class="comment">//返回键值等于key的元素的个数(multimap中使用)</span></span><br><span class="line">x.lower_bound(key)</span><br><span class="line">x.upper_bound(key)</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>树套树（雾</p>
<p><br></p>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">vector</span>&gt;</span><br><span class="line">定义:<span class="built_in">vector</span>&lt;data&gt; x;</span><br><span class="line">迭代器:<span class="built_in">vector</span>&lt;data&gt;::iterator it;</span><br></pre></td></tr></table></figure>
<h2 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x.clear()</span><br><span class="line">x.push_back(key)</span><br><span class="line">x.insert(pos,key)<span class="comment">//在迭代器指针pos处插入一个值key</span></span><br><span class="line">x.erase(it)<span class="comment">//删除迭代器为it的元素,use it=v.erase(it) instead of it++</span></span><br><span class="line">x.erase(l,r)<span class="comment">//删除地址[l,r)的数，l,r为两个迭代器指针</span></span><br><span class="line">x.swap(x2)<span class="comment">//交换x,x2</span></span><br><span class="line">x.reverse(l,r) 翻转地址[l,r)的数，l,r为两个迭代器指针</span><br><span class="line">x.begin() x.end()</span><br><span class="line">x.size() x.empty()</span><br><span class="line">x.lower_bound(key)</span><br><span class="line">x.upper_bound(key)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">定义:<span class="built_in">string</span> x;</span><br><span class="line">迭代器:<span class="built_in">string</span>::iterator it;</span><br></pre></td></tr></table></figure>
<h2 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x.insert(pos,p)<span class="comment">//在pos插入一个串p</span></span><br><span class="line">x.erase(pos,l)<span class="comment">//删除从pos开始l个位置</span></span><br><span class="line">x.replace(pos,l,s)<span class="comment">//将从pos开始l个位置替换成串s</span></span><br><span class="line">x.length() x.size()</span><br><span class="line">x.substr(pos,l)<span class="comment">//截取从pos开始，长为l的子串</span></span><br><span class="line">x.find(s2)<span class="comment">//在s中匹配s2，返回位置，不存在返回-1，类似strstr</span></span><br><span class="line">&lt;&lt; &gt;&gt;输入输出流</span><br><span class="line">+ 拼接 &lt; 字典序</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="rope"><a href="#rope" class="headerlink" title="rope"></a>rope</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;ext/rope&gt;<span class="comment">//can't be used in cena</span></span><br><span class="line">声明:<span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line">定义:crope x;</span><br></pre></td></tr></table></figure>
<h2 id="操作-6"><a href="#操作-6" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x.push_back(ch)<span class="comment">//在末尾添加字符ch</span></span><br><span class="line">x.insert(pos,s)<span class="comment">//在pos位置插入字符ch</span></span><br><span class="line">x.erase(pos,x)<span class="comment">//从pos位置开始删除x个字符</span></span><br><span class="line">x.replace(pos,ch)<span class="comment">//将位置为pos的字符换成ch</span></span><br><span class="line">x.substr(pos,x)<span class="comment">//截取从pos开始，长为l的子串</span></span><br><span class="line">x.length() x.size()</span><br><span class="line">&lt;&lt; &gt;&gt;输入输出流</span><br><span class="line">-&gt;at(x)/[x]<span class="comment">//访问</span></span><br><span class="line">+ 拼接 &lt; 字典序</span><br></pre></td></tr></table></figure>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><h3 id="区间翻转"><a href="#区间翻转" class="headerlink" title="区间翻转"></a>区间翻转</h3><p>同时维护一正一反两个rope……反转即交换两个子串……Orz……</p>
<h3 id="区间循环位移"><a href="#区间循环位移" class="headerlink" title="区间循环位移"></a>区间循环位移</h3><p>拆成多个子串连起来就好了……</p>
<h3 id="可持久化"><a href="#可持久化" class="headerlink" title="可持久化"></a>可持久化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可持久化并查集</span></span><br><span class="line">fa[<span class="number">0</span>]=<span class="keyword">new</span> rope&lt;<span class="keyword">int</span>&gt;(a,a+n+<span class="number">1</span>);fa[i]=<span class="keyword">new</span> rope&lt;<span class="keyword">int</span>&gt;(*fa[i<span class="number">-1</span>]);</span><br><span class="line">它可以实现O(<span class="number">1</span>)的拷贝历史版本，由于rope的底层是平衡树，copy时copy根节点就行了</span><br><span class="line">用它就可以轻松实现可持久化数组</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">bitset</span>&gt;</span><br><span class="line">定义:<span class="built_in">bitset</span>&lt;M&gt; x;<span class="comment">//M:长度</span></span><br></pre></td></tr></table></figure>
<h2 id="操作-7"><a href="#操作-7" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="built_in">set</span>()<span class="comment">//按位清1</span></span><br><span class="line">x.reset()<span class="comment">//按位清0</span></span><br><span class="line">x.flip()<span class="comment">//逐位取反</span></span><br><span class="line">x.any()<span class="comment">//x中存在为1的二进制位返回1</span></span><br><span class="line">x.count()<span class="comment">//x中为1的二进制位数</span></span><br><span class="line">x.to_ullong()<span class="comment">//把x转为类型为unsigned long long的数</span></span><br><span class="line">支持位运算</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[回文双子星]]></title>
      <url>/%E5%9B%9E%E6%96%87%E5%8F%8C%E5%AD%90%E6%98%9F.html</url>
      <content type="html"><![CDATA[<h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>$Manacher$算法能在线性的时间求得以每个位置为中心，能构成的最长回文串的半径</p>
<p>&lt;!<del>more</del>&gt;</p>
<h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><ol>
<li>在所有空隙位置(包括首尾)插入一个原串中不会出现的符号，处理偶数长度回文串</li>
<li>维护$MaxRight$表示当前访问到的回文字串中右端点的$max$，$pos$表示$maxright$对应的回文串的对称轴位置</li>
<li>利用回文串的对称性进行扩展</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000003914228" target="_blank" rel="noopener">notes</a></p>
<p>$O(n)$</p>
<h2 id="回文自动机"><a href="#回文自动机" class="headerlink" title="回文自动机"></a>回文自动机</h2>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 回文 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[素数]]></title>
      <url>/%E7%B4%A0%E6%95%B0.html</url>
      <content type="html"><![CDATA[<h1 id="高斯素数定理"><a href="#高斯素数定理" class="headerlink" title="高斯素数定理"></a>高斯素数定理</h1><p><br></p>
<div class="note info"><p>估计不超过x的素数个数，比真实值略小</p></div>
<p>$\pi(x) \sim \frac{x}{\ln x}$</p>
<a id="more"></a>
<p><br></p>
<h1 id="素性测试"><a href="#素性测试" class="headerlink" title="素性测试"></a>素性测试</h1><p><br></p>
<div class="note info"><p>判断$P$是否为素数</p></div>
<h2 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//简单优化：预处理素数表</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="built_in">sqrt</span>(x+<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(\sqrt{n})$</p>
<h2 id="Wilson-theorem"><a href="#Wilson-theorem" class="headerlink" title="Wilson theorem"></a>Wilson theorem</h2><p>$(P-1)! \equiv -1 \pmod{P}\Rightarrow P$为素数</p>
<p>由于阶乘爆炸增长，无法实际应用</p>
<h2 id="Miller-Rabin测试"><a href="#Miller-Rabin测试" class="headerlink" title="Miller-Rabin测试"></a>Miller-Rabin测试</h2><p>基于一定概率的快速判断方法</p>
<p>定理一：费马小定理的逆定理</p>
<p>$(a,P)=1$且$a^{P-1} \equiv 1 \pmod{P}\Rightarrow P$为素数</p>
<p>但是这是不正确的</p>
<p>卡迈克尔数：一个合数$x$，对于所有满足$(a,x)=1$的正整数$a$都有$a^{x-1}$ $\equiv 1$ $\pmod{x}$成立</p>
<p>定理二：二次探测定理</p>
<p>$0 &lt;x &lt; P$,$x^2 \; \% P=1$且$x=1$或$x=P-1$$\Rightarrow P$为素数</p>
<p>也存在问题……</p>
<p>结合两个定理多次选取基底测试，错误率可以忽略不计</p>
<p>$O(k\log )$，$k$为选取的基底个数</p>
<p><br></p>
<h1 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h1><p><br></p>
<div class="note info"><p>用质因数分解序列唯一表示一个大数</p></div>
<p>任何大于$1$的自然数，都可以唯一分解成有限个质数的乘积</p>
<h2 id="因子数与因子和"><a href="#因子数与因子和" class="headerlink" title="因子数与因子和"></a>因子数与因子和</h2><p>由乘法原理，因子数$d(x)=\prod\limits_{i=1}^{k}(e_i+1)$</p>
<p>求一个数的所有因子可以使用dfs实现</p>
<p>由等比数列求和公式，因子和$s(x)=\prod\limits_{i=1}^{k}\frac{p_i^{e_i+1}-1}{p_i-1}$</p>
<p><br></p>
<h1 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h1><p><br></p>
<h2 id="试除法-1"><a href="#试除法-1" class="headerlink" title="试除法"></a>试除法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//简单优化：预处理素数表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="built_in">sqrt</span>(x+<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x%i))&#123;</span><br><span class="line">            base[++cnt]=i;</span><br><span class="line">            <span class="keyword">while</span>(!(x%i)) x/=i,++idx[cnt];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">1</span>) base[++cnt]=x,idx[cnt]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(\sqrt{n})$</p>
<h2 id="Pollard-Rho算法"><a href="#Pollard-Rho算法" class="headerlink" title="Pollard Rho算法"></a>Pollard Rho算法</h2><p>非常有趣的算法</p>
<p>采用随机化，通过$Birthday$ $Trick$提高概率，$Floyd$判圈法判断</p>
<p>$O(n^{1/4})$</p>
<a class="btn" href="http://mmh.ac.cn/pdf/Pollard-rho算法详解.pdf" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>详解</a>
<p><br></p>
<h1 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h1><p><br></p>
<h2 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eratosthenes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;=n;j+=i) vis[j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n \log \log n)$</p>
<h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>筛积性函数</p>
<p>tricks:筛每个数的最小/最大质因子及其幂指数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;<span class="comment">//全家桶 d[i]:最小质因子幂 cnt[i]:因子数 </span></span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) p[++p[<span class="number">0</span>]]=i,u[i]=<span class="number">-1</span>,phi[i]=i<span class="number">-1</span>,d[i]=<span class="number">1</span>,cnt[i]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p[<span class="number">0</span>]&amp;&amp;i*p[j]&lt;=n;j++)&#123;</span><br><span class="line">            vis[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                u[i*p[j]]=<span class="number">0</span>;</span><br><span class="line">                phi[i*p[j]]=phi[i]*p[j];</span><br><span class="line">                d[i*p[j]]=d[i]+<span class="number">1</span>;</span><br><span class="line">                cnt[i*p[j]]=cnt[i]/(d[i]+<span class="number">1</span>)*(d[i]+<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            u[i*p[j]]=-u[i];</span><br><span class="line">            phi[i*p[j]]=phi[i]*(p[j]<span class="number">-1</span>);</span><br><span class="line">            d[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            cnt[i*p[j]]=cnt[i]*<span class="number">2</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n)$</p>
<a class="btn" href="http://mmh.ac.cn/pdf/贾志鹏线性筛.pdf" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>经典课件</a>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><p>解决一类积性函数求前缀和问题</p>
<p>$O(n^{2/3})$</p>
<a class="btn" href="http://blog.csdn.net/skywalkert/article/details/50500009" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>唐教的介绍</a>
<h2 id="州阁筛"><a href="#州阁筛" class="headerlink" title="州阁筛"></a>州阁筛</h2><p>$O(\frac{n^{3/4}}{\log n})$</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[闷声反大演]]></title>
      <url>/%E9%97%B7%E5%A3%B0%E5%8F%8D%E5%A4%A7%E6%BC%94.html</url>
      <content type="html"><![CDATA[<h2 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h2><p>若函数$f(n)$满足定义域为正整数域，值域为复数域，即$f$：$Z^+→C$ ，称$f(n)$为数论函数</p>
<p>若数论函数$f(n)$对于互质的两个正整数$p$、$q$，有$f(p⋅q)=f(p)⋅f(q)$，称$f(n)$为积性函数</p>
<p>若数论函数$f(n)$对于任意两个正整数$p$、$q$，有$f(p⋅q)=f(p)⋅f(q)$，称$f(n)$为完全积性函数</p>
<a id="more"></a>
<h3 id="常见的完全积性函数"><a href="#常见的完全积性函数" class="headerlink" title="常见的完全积性函数"></a>常见的完全积性函数</h3><ol>
<li><strong>元函数</strong> $e(n)=[n=1]$，狄利克雷卷积的乘法单位元</li>
<li><strong>恒等函数</strong> $I(n)=1$</li>
<li><strong>单位函数</strong> $id(n)=n$</li>
<li><strong>幂函数</strong> $id^k(n)=n^k$</li>
</ol>
<h3 id="常见的积性函数"><a href="#常见的积性函数" class="headerlink" title="常见的积性函数"></a>常见的积性函数</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><ol>
<li><strong>除数函数</strong> $\sigma_k(n)=\sum\limits_{d|n}{d^k}$</li>
<li><strong>约数个数函数</strong>  $\tau(n)=\sigma_0(n)=\sum\limits_{d|n}{1}$</li>
<li><strong>约数和函数</strong> $\sigma(n)=\sigma_1(n)=\sum\limits_{d|n}{d}$</li>
<li><strong>欧拉函数</strong> $\varphi(n)=\sum\limits_{i=1}^{n}{[(n,i)=1]}$</li>
<li><strong>莫比乌斯函数</strong> 对于无平方因子数$n=\prod\limits_{i=1}^{t}p_i$，$\mu(n)=(-1)^t$；对于有平方因子数$n$，$\mu(n)=0$；在狄利克雷卷积的乘法中与恒等函数互为逆元</li>
</ol>
<h3 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h3><ul>
<li><p>$\sum\limits_{d|n}{\mu(d)}=[n=1]$</p>
</li>
<li><p>$\sum\limits_{d|n}{\varphi(d)}=n$</p>
</li>
<li><p>$\sum\limits_{d|n}{\frac{\mu(d)}{d}}=\frac{\varphi(n)}{n}$ 此式中为分数</p>
</li>
<li><p>$\sum_{i=1}^{n}i\cdot[(n,i)=1]=\frac{n\varphi(n)+[n=1]}{2}$ 与n互质数的和</p>
</li>
</ul>
<h2 id="狄利克雷卷积与莫比乌斯反演"><a href="#狄利克雷卷积与莫比乌斯反演" class="headerlink" title="狄利克雷卷积与莫比乌斯反演"></a>狄利克雷卷积与莫比乌斯反演</h2><p>数论函数$f$和$g$的狄利克雷卷积定义为</p>
<script type="math/tex; mode=display">(f \times g)(n)=\sum\limits_{d|n}{f(d)~g(\frac{n}{d})}</script><p><strong>交换律</strong>：$f \times g=g \times f$</p>
<p><strong>结合律</strong>：$(f \times g) \times h=f \times (g \times h)$</p>
<p><strong>单位元</strong>：$f \times e =f$</p>
<p><strong>加法分配律</strong>：$f \times (g+h)=f \times g+ f\times h$</p>
<p>在上文数论函数的部分中提到，$\mu \times I = e$，利用这个等式可以解决下面的问题</p>
<p>已知$g(n)$&amp;$g(n)=\sum\limits_{d|n}{f(d)}$，求$f(n)$</p>
<p>$\because $  $f \times I=\sum\limits_{d|n}{f(d)~I(\frac{n}{d})}=g$</p>
<p>$\therefore $ $f \times I \times \mu=g \times \mu$</p>
<p>即$f=\mu \times g,f(n)=\sum\limits_{d|n}{\mu(d)~ g(\frac{n}{d})}                                                                                        ①$</p>
<p>类似地，若已知$g(n)$&amp;$g(n)=\sum\limits_{n|d}{f(d)}$</p>
<p>可以得到$f(n)=\sum\limits_{n|d}{\mu(\frac{d}{n}) ~ g(d)}②$</p>
<p>以上利用$\mu$实现$f$和$g$互相转化的过程称为莫比乌斯反演</p>
<h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 反演 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二进制]]></title>
      <url>/%E4%BA%8C%E8%BF%9B%E5%88%B6.html</url>
      <content type="html"><![CDATA[<div class="note danger"><p>位运算的优先级比较奇怪，请加括号使用</p></div>

<p>C/C++语言提供的位运算符</p>
<p><img src="/img/2.png" width="100%" height="100%"></p>
<a id="more"></a>
<p>用$x$表示一个10进制数，记其二进制展开从最右边开始为第$0、1、2…$位</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">语句</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">获取$x$的第$i$位</td>
<td style="text-align:center">x&amp;(1&lt;&lt;i)</td>
<td style="text-align:center">若$x$的第$i$位为$1$，值为$2^i$</td>
</tr>
<tr>
<td style="text-align:center">bar</td>
<td style="text-align:center">bar</td>
<td style="text-align:center">bar</td>
</tr>
<tr>
<td style="text-align:center">查询$x$中$1$的个数</td>
<td style="text-align:center">__builtin_popcount(x)</td>
<td style="text-align:center">GCC内建函数</td>
</tr>
<tr>
<td style="text-align:center">提取lowbit(x)</td>
<td style="text-align:center">x&amp;(-x)</td>
<td style="text-align:center">可以遍历$x$中所有$1$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">语句</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">判断奇偶性</td>
<td style="text-align:center">x&amp;1</td>
<td style="text-align:center">值为$1$则$x$为奇数</td>
</tr>
<tr>
<td style="text-align:center">乘除$2$</td>
<td style="text-align:center">&lt;&lt; &amp; &gt;&gt;</td>
<td style="text-align:center">根据实际意义</td>
</tr>
<tr>
<td style="text-align:center">对$2$的幂取模</td>
<td style="text-align:center">__builtin_popcount(x)</td>
<td style="text-align:center">GCC内建函数</td>
</tr>
<tr>
<td style="text-align:center">交换两个数</td>
<td style="text-align:center">a^=b,b^=a,a^=b</td>
<td style="text-align:center">根据实际意义</td>
</tr>
</tbody>
</table>
</div>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>用二进制数表示集合，设单个二进制数最大位宽为$w$</p>
<h3 id="修改-amp-查询-amp-删除"><a href="#修改-amp-查询-amp-删除" class="headerlink" title="修改&amp;查询&amp;删除"></a>修改&amp;查询&amp;删除</h3><p>直接上……</p>
<p>$O(1)$</p>
<h3 id="集合交-amp-并-amp-差-amp-补"><a href="#集合交-amp-并-amp-差-amp-补" class="headerlink" title="集合交&amp;并&amp;差&amp;补"></a>集合交&amp;并&amp;差&amp;补</h3><p>x&amp;y<br>x|y<br>x^(x&amp;y)<br>~x</p>
<p>$O(\frac{n}{w})$</p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>位运算每一位相互独立，互不干扰，可以按位考虑，进行dp/贪心</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 黑科技 </tag>
            
            <tag> 二进制 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分块与莫队]]></title>
      <url>/%E5%88%86%E5%9D%97%E4%B8%8E%E8%8E%AB%E9%98%9F.html</url>
      <content type="html"><![CDATA[<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>优雅的暴力</p>
<a id="more"></a>
<h3 id="均值法"><a href="#均值法" class="headerlink" title="均值法"></a>均值法</h3><p>合理确定块的大小</p>
<p>核心思想是让两部分时间复杂度划等号</p>
<h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><p>区间</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 黑科技 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[同余]]></title>
      <url>/%E5%90%8C%E4%BD%99.html</url>
      <content type="html"><![CDATA[<h1 id="同余式性质"><a href="#同余式性质" class="headerlink" title="同余式性质"></a>同余式性质</h1><p><br></p>
<div class="note info"><p>$a\equiv b \pmod{m}$</p></div>
<ol>
<li>反身性 $a \equiv a \pmod {m}$</li>
<li>对称性 $a \equiv b \pmod {m}$ $\Rightarrow$ $ b \equiv a \pmod {m}$</li>
<li>传递性 $a \equiv b \pmod {m}$,$b \equiv c \pmod {m}$ $\Rightarrow$ $a \equiv c \pmod {m}$</li>
<li>相加 $a \equiv b \pmod {m}$,$c \equiv d \pmod {m}$ $\Rightarrow$ $a \pm c \equiv b \pm d \pmod {m}$</li>
<li>相乘 $a \equiv b \pmod {m}$,$c \equiv d \pmod {m}$ $\Rightarrow$ $ac \equiv bd \pmod {m}$</li>
<li>除法 $ac \equiv bd \pmod {m}$ $\Rightarrow$ $a \equiv b \pmod { \frac{m}{(c,m)}}$</li>
<li>乘幂 $a \equiv b \pmod {m}$ $\Rightarrow$ $a^n \equiv b^n \pmod {m}$ </li>
</ol>
<a id="more"></a>
<p><br></p>
<h1 id="剩余系"><a href="#剩余系" class="headerlink" title="剩余系"></a>剩余系</h1><p><br></p>
<div class="note info"><p><strong>完全剩余系</strong>：模$n$意义下的完全剩余系$Z_n=${$0,1,…n-1$}，每个元素代表一个同余等价类<br><strong>缩系</strong>：模$n$意义下的缩系$Z_n*=${$x|x \in Z_n,(x,n)=1$}</p></div>
<h2 id="模m意义下乘法群逆元"><a href="#模m意义下乘法群逆元" class="headerlink" title="模m意义下乘法群逆元"></a>模m意义下乘法群逆元</h2><p>$ax\equiv 1 \pmod{m}$</p>
<p>$(a,m)=1 \Rightarrow x$存在</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>存在唯一性</li>
<li>完全积性函数</li>
<li>$a/b\equiv a\times inv(b) \pmod{m}$</li>
</ol>
<h3 id="Calc"><a href="#Calc" class="headerlink" title="Calc"></a><strong>Calc</strong></h3><p><strong>Euler theorem</strong></p>
<p>若正整数$a$、$m$互质</p>
<p>$a^{\varphi (m)} \equiv 1 \pmod {m}$</p>
<p><strong>Fermat’s little theorem</strong></p>
<p>若正整数$a$、$m$互质且$m$为质数</p>
<p>$a^{m-1} \equiv 1 \pmod {m}$</p>
<p><strong>EX Euclid algorithm</strong></p>
<p>根据定义求解同余方程</p>
<p><strong>线性递推</strong></p>
<p>$inv(i) \equiv (m-\frac{m}{i})\times inv(m \% i) \pmod{m}$</p>
<a class="btn" href="http://blog.csdn.net/y20070316/article/details/50578435" target="_blank" rel="noopener"><i class="fa fa-key fa-lg fa-fw"></i>推导与证明</a>
<p><br></p>
<h1 id="模意义下的运算"><a href="#模意义下的运算" class="headerlink" title="模意义下的运算"></a>模意义下的运算</h1><p><br></p>
<h2 id="常见运算取模"><a href="#常见运算取模" class="headerlink" title="常见运算取模"></a>常见运算取模</h2><div class="note info"><p>$+、-、\times、\div、$^</p></div>
<p>$a +b \equiv((a \mod m)+(b \mod m)) \pmod {m}$</p>
<p>$a -b \equiv((a \mod m)-(b \mod m)+m)\pmod {m}$</p>
<p>$ab \equiv ((a\mod m)(b \mod m))\pmod {m}$</p>
<p><br></p>
<p>$a/b \mod m$</p>
<p>$Case1:a|b$</p>
<p>if((b,m)=1) 乘法逆元求解<br>else $a/b \equiv (a\% bm)/b \pmod{m}$ </p>
<p>$Case2:!(a|b)$</p>
<p>$c=a \% b,a/b \equiv ((a-c)\% bm)/b\pmod{m}$</p>
<p><br></p>
<p>$a^b \mod m$</p>
<p>$Case1:$减小a</p>
<script type="math/tex; mode=display">a^b \equiv (a \% m)^b \pmod {m}</script><p>$Case2:$减小b</p>
<script type="math/tex; mode=display">a^b\equiv
\begin{cases}
a^{b\%\varphi(m)}\qquad \quad \qquad (a,m)=1\\
a^b\qquad \qquad \qquad \quad ~(a,m)\neq1,b<\varphi(m)\\
a^{b\%\varphi(m)+\varphi(m)}\qquad \quad (a,m)\neq1,b\geq\varphi(m)
\end{cases}\qquad (mod~m)</script><p>(EX Euler theorem)</p>
<h2 id="组合数取模"><a href="#组合数取模" class="headerlink" title="组合数取模"></a>组合数取模</h2><div class="note info"><p>$C_{n}^{m} \mod P$</p></div>
<p>$Case1:$$n,m \leq 1000,P \leq 10^9$</p>
<p>杨辉三角递推求解</p>
<p>$Case2:$$n,m \leq 10^6$</p>
<p>分解质因数/预处理逆元和逆元的阶乘根据定义计算</p>
<p>$Case3:$$n,m \leq 10^{18},P \leq 10^5$</p>
<p><strong>if P is a Prime</strong></p>
<h3 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h3><p>$C(n,m) \equiv C(n\% P,m \% P) \times C(n/P,m/P)$</p>
<p><strong>if P is not a Prime</strong></p>
<h3 id="EX-Lucas-定理"><a href="#EX-Lucas-定理" class="headerlink" title="EX Lucas 定理"></a>EX Lucas 定理</h3><p>对$P$进行质因数分解，对每个质因子得到一个同余方程，使用$CRT$合并</p>
<p>现在需要求$C_{n}^{m} \% p_i^{e_i}$，也即$n! \% p_i^{e_i}$</p>
<p>分三部分求解</p>
<ol>
<li>$p_i$的幂，直接求解</li>
<li>一个新的阶乘，递归求解</li>
<li>剩下的暴力求解</li>
</ol>
<a class="btn" href="https://www.cnblogs.com/candy99/p/6637629.html" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>笔记</a>
<a class="btn" href="http://blog.csdn.net/clove_unique/article/details/54571216" target="_blank" rel="noopener"><i class="fa fa-key fa-lg fa-fw"></i>推导与证明</a>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多项式与生成函数]]></title>
      <url>/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0.html</url>
      <content type="html"><![CDATA[<h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><p><br></p>
<h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><div class="note info"><p><strong>系数表示法</strong>：$F(x)=\sum\limits_{i=0}^{n}a_ix^i$</p>
<p><strong>点值表示法</strong>：$(x_0,y_0),(x_1,y_1),\cdots,(x_n,y_n)$</p>
<p>对于多项式$A(x)$，称其最高项的次数为这个多项式的<strong>度</strong>，记作$degA$</p></div>
<a id="more"></a>
<p><br></p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><div class="note info"><p><strong>多项式加减</strong>：采用系数表示法，进行向量加减</p>
<p><strong>多项式乘法</strong>：采用点值表示法，将点的坐标相乘</p></div>
<p><br></p>
<h3 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换(FFT)"></a>快速傅里叶变换(FFT)</h3><p>基础知识部分待填坑</p>
<div class="note info"><p><strong>DTF</strong>：系数表示法-&gt;点值表示法<br><strong>逆DFT</strong>：点值表示法-&gt;系数表示法<br>利用单位复数根的性质，可以在$O(n \log n)$的时间复杂度内完成</p></div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; C;<span class="comment">//复数库</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>) L++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));<span class="comment">//求逆序表：末位为0，直接为其前一半逆序表的值右移一位，末位为1，在最高位添加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(C *a,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(R[i]&gt;i) swap(a[i],a[R[i]]);<span class="comment">//利用逆序表，快速求逆序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        C wn(cos(pi/i),f*sin(pi/i));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="function">C <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++,w*=wn)&#123;</span><br><span class="line">                C x=a[j+k],y=w*a[j+k+i];</span><br><span class="line">                a[j+k]=x+y;a[j+k+i]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]/=n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a class="btn" href="http://www.gatevin.moe/acm/fft算法学习笔记/" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>笔记</a>
<p><br></p>
<h3 id="快速数论变换-NTT"><a href="#快速数论变换-NTT" class="headerlink" title="快速数论变换(NTT)"></a>快速数论变换(NTT)</h3><div class="note danger"><p>FFT的缺点：常数大，炸精度，无法在模意义下求解</p></div>
<p><i class="fa fa-key"></i> 新的算法</p>
<div class="note success"><p>数论意义下</p>
<p>一般模数$P=a \cdot 2^m +1,a$是一个较小的数</p>
<p>用原根代替单位复数根</p></div>
<a class="btn" href="https://www.cnblogs.com/candy99/p/6641972.html算法学习笔记/" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>笔记</a>
<p><br></p>
<h3 id="快速沃尔什变换-FWT"><a href="#快速沃尔什变换-FWT" class="headerlink" title="快速沃尔什变换(FWT)"></a>快速沃尔什变换(FWT)</h3><p>大坑待填</p>
<a class="btn" href="http://picks.logdown.com/posts/179290-fast-walsh-hadamard-transform算法学习笔记/" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>笔记</a>
<p><br></p>
<h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h3><div class="note info"><p>对于多项式$A(x),B(x)$，存在唯一的$Q(x),R(x)$<br>满足$A(x)=Q(x)B(x)+R(x)$，其中$degR&lt;degB$<br>称$Q(x)$为$B(x)$除$A(x)$的<strong>商</strong>，$R(x)$为$B(x)$除$A(x)$的<strong>余数</strong><br>记作$A(x) \equiv R(x) \pmod {B(x)}$</p>
<p>对于多项式$A(x)$，若存在$B(x)$满足$degB≤degA$，<br>并且$A(x)B(x) \equiv 1 \pmod {x^n}$，那么称$B(x)$为$A(x)$在$mod$ $x^n$意义下的<strong>逆元</strong>，记作$A^{-1}(x)$</p></div>
<p>采用倍增思想，设$B(x)$为$\bmod x^{\lceil \frac{n}{2} \rceil}$意义下$A(x)$的逆元</p>
<p>经过推导，最后可以得到</p>
<script type="math/tex; mode=display">A^{-1}(x) \equiv 2B(x) - A(x)B^2(x) \pmod {x^n}</script><p>递归$FFT$就可以搞了,同时易知多项式有逆元的充分必要条件为常数项有逆元</p>
<p>$O(n \log n)$，常数约为$FFT$的$6$倍</p>
<a class="btn" href="http://blog.miskcoo.com/2015/05/polynomial-inverse" target="_blank" rel="noopener"><i class="fa fa-arrows-alt fa-lg fa-fw"></i>推导</a>
<p><br></p>
<h3 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a>多项式除法</h3><p>大坑待填</p>
<p><br></p>
<h3 id="多项式取模"><a href="#多项式取模" class="headerlink" title="多项式取模"></a>多项式取模</h3><p>大坑待填</p>
<p><br></p>
<h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p>给出$G(x)$，求$F(x)$，满足</p>
<script type="math/tex; mode=display">G(f(x)) \equiv 0 \pmod {x^n}</script><p><br></p>
<h3 id="多项式开方"><a href="#多项式开方" class="headerlink" title="多项式开方"></a>多项式开方</h3><p>求$B^2(x) \equiv A(x) \pmod {x^n}$</p>
<p>类似多项式求逆，设$B_0(x)$为$\bmod x^{\lceil \frac{n}{2} \rceil}$意义下$A(x)$的平方根</p>
<p>整理后得到</p>
<script type="math/tex; mode=display">B(x)=\frac{B_0(x)+A(x)B_0^{-1}(x)}{2} \pmod {x^n}</script><p>$O(n \log n)$</p>
<p><br></p>
<h3 id="多项式In"><a href="#多项式In" class="headerlink" title="多项式In"></a>多项式In</h3><p>求导……</p>
<p><br></p>
<h3 id="多项式exp"><a href="#多项式exp" class="headerlink" title="多项式exp"></a>多项式exp</h3><p>取对数后使用牛顿迭代法</p>
<p><br></p>
<h3 id="多项式k次幂"><a href="#多项式k次幂" class="headerlink" title="多项式k次幂"></a>多项式k次幂</h3><p>……</p>
<p><br></p>
<h3 id="多项式复合"><a href="#多项式复合" class="headerlink" title="多项式复合"></a>多项式复合</h3><p>……</p>
<p><br></p>
<h3 id="多项式多点求值与插值"><a href="#多项式多点求值与插值" class="headerlink" title="多项式多点求值与插值"></a>多项式多点求值与插值</h3><p><strong>多点求值</strong>：给出多项式$A(x)$和$n$个点$x_0, x_1, \cdots, x_{n-1}$，要求求出$A(x_0)$, $A(x_1)$, $\cdots$, $A(x_{n-1})$</p>
<p><strong>插值</strong>：给出n+1个点$(x_0, y_0), (x_1, y_1), \cdots, (x_n, y_n)$，求出一个$n$次多项式，使得这些点都在这个多项式上</p>
<p>大力搞搞……</p>
<p><br></p>
<p><strong>参考资料</strong><br><div class="note primary"><p><a href="http://blog.miskcoo.com/" target="_blank" rel="noopener">Orz Miskcoo</a>；<a href="http://blog.miskcoo.com/" target="_blank" rel="noopener">Orz Miskcoo</a>；<a href="http://www.cnblogs.com/candy99/p/6744332.html" target="_blank" rel="noopener">Orz Candy?</a></p>
<p><a href="http://m.blog.csdn.net/semiwaker/article/details/73251486" target="_blank" rel="noopener">总结1</a>；<a href="http://blog.csdn.net/coldef/article/details/76020530" target="_blank" rel="noopener">总结2</a></p></div></p>
<p><br></p>
<h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p><br></p>
<h2 id="普通型生成函数"><a href="#普通型生成函数" class="headerlink" title="普通型生成函数"></a>普通型生成函数</h2><div class="note info"><p>定义序列$a_n$的普通型生成函数 (Ordinary Generating Function, OGF)，为</p>
<script type="math/tex; mode=display">A(x)=\sum_\limits{i=0}^{}a_ix^i</script></div>
<h2 id="指数型生成函数"><a href="#指数型生成函数" class="headerlink" title="指数型生成函数"></a>指数型生成函数</h2><div class="note info"><p>定义序列$a_n$的指数型生成函数 (Exponential Generating Function, EGF) ，为</p>
<script type="math/tex; mode=display">A(x)=\sum_\limits{i=0}^{}a_i \frac{x^i}{i!}</script></div>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[平面几何]]></title>
      <url>/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95.html</url>
      <content type="html"><![CDATA[<h2 id="点"><a href="#点" class="headerlink" title="点"></a>点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    Point()&#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> _,<span class="keyword">double</span> __)&#123;x=_,y=__;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="线"><a href="#线" class="headerlink" title="线"></a>线</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span><span class="comment">//使用向量式表示，线上的点X满足X=P+tV，直线t∈R,线段t∈[0,1],射线t&gt;0</span></span><br><span class="line">    Point P;<span class="comment">//线上一点</span></span><br><span class="line">    Vector V;<span class="comment">//方向向量，已知线上两个不同点A、B，则V=B-A</span></span><br><span class="line">	Line()&#123;&#125;</span><br><span class="line">    Line(Point _,Vector __)&#123;P=_,V=__;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">    Point c;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    Circle()&#123;&#125;</span><br><span class="line">    Circle(Point _,<span class="keyword">double</span> __)&#123;c=_,r=__;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;<span class="comment">////通过圆心角确定圆上坐标</span></span><br><span class="line">        <span class="keyword">return</span> Point(c.x+<span class="built_in">cos</span>(a)*r,c.y+<span class="built_in">sin</span>(a)*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Polygon</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; P;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br></pre></td></tr></table></figure>
<h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vector <span class="keyword">operator</span> + (Vector A,Vector B)&#123;<span class="keyword">return</span> Vector(A.x+B.x,A.y+B.y);&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Vector A,Vector B)&#123;<span class="keyword">return</span> Vector(A.x-B.x,A.y-B.y);&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> * (Vector A,<span class="keyword">double</span> p)&#123;<span class="keyword">return</span> Vector(A.x*p,A.y*p);&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> / (Vector A,<span class="keyword">double</span> p)&#123;<span class="keyword">return</span> Vector(A.x/p,A.y/p);&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点积与叉积"><a href="#点积与叉积" class="headerlink" title="点积与叉积"></a>点积与叉积</h3><p>点积几何意义：$U$在$V$上的投影的模长乘$V$的模长，可以判断向量垂直</p>
<p>叉积几何意义：以$U$、$V$为邻边构成的平行四边形的有向面积，可以判断向量平行</p>
<p>把点积和叉积组合到一起可以判断两个向量的位置关系</p>
<p><img src="/img/1.png" width="50%" height="50%"></p>
<p>左图点积，右图叉积：对于向量$a$、$b$，$b$在蓝色区域为正，绿色区域为负</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dot</span><span class="params">(Vector A,Vector B)</span></span>&#123;<span class="keyword">return</span> A.x*B.x+A.y*B.y;&#125;<span class="comment">//|A||B|cos(θ)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector A,Vector B)</span></span>&#123;<span class="keyword">return</span> A.x*B.y-A.y*B.x;&#125;<span class="comment">//|A||B|sin(θ)</span></span><br></pre></td></tr></table></figure>
<h3 id="模长、投影与夹角"><a href="#模长、投影与夹角" class="headerlink" title="模长、投影与夹角"></a>模长、投影与夹角</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Length</span><span class="params">(Vector A)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(Dot(A,A));&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Shade</span><span class="params">(Vector A,Vector B)</span></span>&#123;<span class="keyword">return</span> Dot(A,B)/Length(B);&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Angle</span><span class="params">(Vector A,Vector B)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span>(Dot(A,B)/Length(A)/Length(B));&#125;</span><br></pre></td></tr></table></figure>
<h3 id="极角"><a href="#极角" class="headerlink" title="极角"></a>极角</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Polar</span><span class="params">(Vector A)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(A.y,A.x);&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转与单位法向量"><a href="#旋转与单位法向量" class="headerlink" title="旋转与单位法向量"></a>旋转与单位法向量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector A,<span class="keyword">double</span> rad)</span></span>&#123;<span class="keyword">return</span> Vector(A.x*<span class="built_in">cos</span>(rad)-A.y*<span class="built_in">sin</span>(rad),A.x*<span class="built_in">sin</span>(rad)+A.y*<span class="built_in">cos</span>(rad));&#125;</span><br><span class="line"><span class="function">Vector <span class="title">Normal</span><span class="params">(Vector A)</span></span>&#123;<span class="comment">//左转90°，长度归1</span></span><br><span class="line">    <span class="keyword">double</span> L=Length(A);</span><br><span class="line">    <span class="keyword">return</span> Vector(-A.y/L,A.x/L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h2><h3 id="两点间距离"><a href="#两点间距离" class="headerlink" title="两点间距离"></a>两点间距离</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DistanceToPoint</span><span class="params">(Point A,Point B)</span></span>&#123;<span class="keyword">return</span> Length(A-B);&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点到直线间距离"><a href="#点到直线间距离" class="headerlink" title="点到直线间距离"></a>点到直线间距离</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DistanceToLine</span><span class="params">(Line A,Point B)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>(Cross(B-A.P,A.V)/Length(A.V));&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点到线段间距离"><a href="#点到线段间距离" class="headerlink" title="点到线段间距离"></a>点到线段间距离</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点到线段的距离</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DistanceToSegment</span><span class="params">(Point P,Point A,Point B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A==B) <span class="keyword">return</span> Length(P-A);</span><br><span class="line">    Vector v1=B-A,v2=P-A,v3=P-B;</span><br><span class="line">    <span class="keyword">if</span>(dcmp(Dot(v1,v2))&lt;<span class="number">0</span>) <span class="keyword">return</span> Length(v2);</span><br><span class="line">    <span class="keyword">if</span>(dcmp(Dot(v1,v3))&gt;<span class="number">0</span>) <span class="keyword">return</span> Length(v3);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(Cross(v1,v2))/Length(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="两直线交点"><a href="#两直线交点" class="headerlink" title="两直线交点"></a>两直线交点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//须确保两直线有唯一交点</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineIntersection</span><span class="params">(Line A,Line B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t=Cross(B.V,A.P-B.P)/Cross(A.V,B.V);</span><br><span class="line">    <span class="keyword">return</span> A.P+A.V*t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点在多边形内判定"><a href="#点在多边形内判定" class="headerlink" title="点在多边形内判定"></a>点在多边形内判定</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p,Polygon poly)</span></span>&#123;<span class="comment">//转角法</span></span><br><span class="line">    <span class="keyword">int</span> wn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=poly.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    	Point C=poly[i],D=poly[(i+<span class="number">1</span>)%n];</span><br><span class="line">        <span class="keyword">if</span>(OnSegment(p,C,D) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//在边界上</span></span><br><span class="line">        <span class="keyword">int</span> k=dcmp(Cross(D-C,p-C));</span><br><span class="line">        <span class="keyword">int</span> d1=dcmp(C.y-p.y),d2=dcmp(D.y-p.y);</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;d1&lt;=<span class="number">0</span>&amp;&amp;d2&gt;<span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>&amp;&amp;d2&lt;=<span class="number">0</span>&amp;&amp;d1&gt;<span class="number">0</span>) wn++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(wn!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//内部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//外部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段相交判定"><a href="#线段相交判定" class="headerlink" title="线段相交判定"></a>线段相交判定</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线段规范相交判定，即交点不在任何一条线段的端点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SegmentProperIntersection</span><span class="params">(Point a1,Point a2,Point b1,Point b2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1=Cross(a2-a1,b1-a1),c2=Cross(a2-a1,b2-a1);</span><br><span class="line">    <span class="keyword">double</span> c3=Cross(b2-b1,a1-b1),c4=Cross(b2-b1,a2-b1);</span><br><span class="line">    <span class="keyword">return</span> dcmp(c1)*dcmp(c2)&lt;<span class="number">0</span>&amp;&amp;dcmp(c3)*dcmp(c4)&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点在线段上判定"><a href="#点在线段上判定" class="headerlink" title="点在线段上判定"></a>点在线段上判定</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断点是否在线段上，不包含端点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point P,Point A,Point B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(Cross(A-P,B-P)==<span class="number">0</span>&amp;&amp;dcmp(Dot(A-P,B-P))&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直线与圆的交点"><a href="#直线与圆的交点" class="headerlink" title="直线与圆的交点"></a>直线与圆的交点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//联立方程组</span></span><br><span class="line"><span class="comment">//直线和圆的交点，返回交点个数，结果存在sol中。</span></span><br><span class="line"><span class="comment">//该代码没有清空sol</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineCircleIntersecion</span><span class="params">(Line L,Circle C,<span class="keyword">double</span> &amp;t1,<span class="keyword">double</span> &amp;t2,<span class="built_in">vector</span>&lt;Point&gt; &amp;sol)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a=L.v.x,b=L.p.x-C.c.x,c=L.v.y,d=L.p.y-C.c.y;</span><br><span class="line">    <span class="keyword">double</span> e=a*a+c*c,f=<span class="number">2</span>*(a*b+c*d),g=b*b+d*d-C.r*C.r;</span><br><span class="line">    <span class="keyword">double</span> delta=f*f<span class="number">-4</span>*e*g;     <span class="comment">//判别式</span></span><br><span class="line">    <span class="keyword">if</span>(dcmp(delta)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//相离</span></span><br><span class="line">    <span class="keyword">if</span>(dcmp(delta)==<span class="number">0</span>)&#123;         <span class="comment">//相切</span></span><br><span class="line">        t1=t2=-f/(<span class="number">2</span>*e);</span><br><span class="line">        sol.push_back(C.point(t1));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相交</span></span><br><span class="line">    t1=(-f-<span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*e);sol.push_back(C.point(t1));</span><br><span class="line">    t2=(-f+<span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*e);sol.push_back(C.point(t2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两圆相交"><a href="#两圆相交" class="headerlink" title="两圆相交"></a>两圆相交</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCircleCircleIntersection</span><span class="params">(Circle C1,Circle C2,<span class="built_in">vector</span>&lt;Point&gt; &amp;sol)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d=Length(C1.c-C2.c);</span><br><span class="line">    <span class="keyword">if</span>(dcmp(d)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dcmp(C1.r-C2.r==<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//两圆完全重合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//两圆为同心圆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dcmp(C1.r+C2.r-d)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dcmp(<span class="built_in">fabs</span>(C1.r-C2.r)==<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span> a=Angle(C2.c-C1.c);<span class="comment">//向量C1C2的极角</span></span><br><span class="line">    <span class="keyword">double</span> da=<span class="built_in">acos</span>((C1.r*C1.r+d*d-C2.r*C2.r)/(<span class="number">2</span>*C1.r*d));</span><br><span class="line">    <span class="comment">//C1C2到C1P1的角</span></span><br><span class="line">    Point p1=C1.point(a-da),p2=C1.point(a+da);</span><br><span class="line">    sol.push_back(p1);</span><br><span class="line">    <span class="keyword">if</span>(p1==p2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    sol.push_back(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过定点做圆的切线"><a href="#过定点做圆的切线" class="headerlink" title="过定点做圆的切线"></a>过定点做圆的切线</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangents</span><span class="params">(Point p,Circle C,Vector *v)</span></span>&#123;</span><br><span class="line">    Vector u=C.c-p;</span><br><span class="line">    <span class="keyword">double</span> dist=Length(u);</span><br><span class="line">    <span class="keyword">if</span>(dist&lt;C.r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dcmp(dist-C.r)==<span class="number">0</span>)&#123;</span><br><span class="line">        v[<span class="number">0</span>]=Rotate(u,PI/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ang=<span class="built_in">asin</span>(C.r/dist);</span><br><span class="line">        v[<span class="number">0</span>]=Rotate(u,-ang);</span><br><span class="line">        v[<span class="number">1</span>]=Rotate(u,+ang);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两圆的公切线"><a href="#两圆的公切线" class="headerlink" title="两圆的公切线"></a>两圆的公切线</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据圆心距判断</span></span><br><span class="line"><span class="comment">//返回切线的个数，-1表示有无数条公切线。</span></span><br><span class="line"><span class="comment">//a[i], b[i] 表示第i条切线在圆A，圆B上的切点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangents</span><span class="params">(Circle A,Circle B,Point *a,Point *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A.r&lt;B.r)&#123;swap(A,B);swap(a,b);&#125;</span><br><span class="line">    <span class="keyword">int</span> d2=(A.c.x-B.c.x)*(A.c.x-B.c.x)+(A.c.y-B.c.y)*(A.c.y-B.c.y);</span><br><span class="line">    <span class="keyword">int</span> rdiff=A.r-B.r;</span><br><span class="line">    <span class="keyword">int</span> rsum=A.r+B.r;</span><br><span class="line">    <span class="keyword">if</span>(d2&lt;rdiff*rdiff) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//内含</span></span><br><span class="line">    <span class="keyword">double</span> base=<span class="built_in">atan2</span>(B.c.y-A.c.y,B.c.x-A.c.x);</span><br><span class="line">    <span class="keyword">if</span>(d2==<span class="number">0</span>&amp;&amp;A.r==B.r) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//无限多条切线</span></span><br><span class="line">    <span class="keyword">if</span>(d2==rdiff*rdiff)&#123;<span class="comment">//内切,一条切线</span></span><br><span class="line">        a[cnt]=A.point(base),b[cnt]=B.point(base),cnt++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有外共切线</span></span><br><span class="line">    <span class="keyword">double</span> ang=<span class="built_in">acos</span>((A.r-B.r)/<span class="built_in">sqrt</span>(d2));</span><br><span class="line">    a[cnt]=A.point(base+ang);b[cnt]=B.point(base+ang);cnt++;</span><br><span class="line">    a[cnt]=A.point(base-ang);b[cnt]=B.point(base-ang);cnt++;</span><br><span class="line">    <span class="keyword">if</span>(d2==rsum*rsum)&#123;<span class="comment">//一条内公切线</span></span><br><span class="line">        a[cnt]=A.point(base);</span><br><span class="line">        b[cnt]=B.point(PI+base);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d2&gt;rsum*rsum)&#123;<span class="comment">//两条内公切线</span></span><br><span class="line">        <span class="keyword">double</span> ang=<span class="built_in">acos</span>((A.r+B.r)/<span class="built_in">sqrt</span>(d2));</span><br><span class="line">        a[cnt]=A.point(base+ang);b[cnt]=B.point(PI+base+ang);cnt++;</span><br><span class="line">        a[cnt]=A.point(base-ang);b[cnt]=B.point(PI+base-ang);cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面积"><a href="#面积" class="headerlink" title="面积"></a>面积</h2><h3 id="多边形的有向面积"><a href="#多边形的有向面积" class="headerlink" title="多边形的有向面积"></a>多边形的有向面积</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PolygonArea</span><span class="params">(Polygon A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.size()<span class="number">-1</span>;i++)</span><br><span class="line">        area+=Cross(A[i].P-A[<span class="number">0</span>].P,A[i+<span class="number">1</span>].P-A[<span class="number">0</span>].P);</span><br><span class="line">    <span class="keyword">return</span> area/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p>包围给定点集的面积最小的凸多边形</p>
<h3 id="Andrew算法"><a href="#Andrew算法" class="headerlink" title="Andrew算法"></a>Andrew算法</h3><p>分别维护上下凸壳，然后合并</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConvexHull</span><span class="params">(Point *p,<span class="keyword">int</span> n,Point* ch)</span></span>&#123;</span><br><span class="line">    sort(p,p+n,cmp);<span class="comment">//按照x、y为第一、二关键字排序 </span></span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">1</span>&amp;&amp;Cross(ch[m<span class="number">-1</span>]-ch[m<span class="number">-2</span>],p[i]-ch[m<span class="number">-2</span>])&lt;=<span class="number">0</span>) m--;<span class="comment">//右手定则，直到方向在左边为止</span></span><br><span class="line">        ch[m++]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;k&amp;&amp;Cross(ch[m<span class="number">-1</span>]-ch[m<span class="number">-2</span>],p[i]-ch[m<span class="number">-2</span>])&lt;=<span class="number">0</span>) m--;</span><br><span class="line">        ch[m++]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) m--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="半平面交"><a href="#半平面交" class="headerlink" title="半平面交"></a>半平面交</h2><p>给出若干个半平面，求它们的公共部分</p>
<h3 id="半平面"><a href="#半平面" class="headerlink" title="半平面"></a>半平面</h3><p>半平面用有向直线表示，它的左侧就是它所代表的半平面</p>
<h3 id="增量法"><a href="#增量法" class="headerlink" title="增量法"></a>增量法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitPolygon</span><span class="params">(Polygon &amp;poly)</span><span class="comment">//初始化答案为整个平面，结束后删除</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    poly[poly.n++]=Point(INF,INF);</span><br><span class="line">    poly[poly.n++]=Point(INF,-INF);</span><br><span class="line">    poly[poly.n++]=Point(-INF,INF);</span><br><span class="line">    poly[poly.n++]=Point(-INF,-INF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polygon <span class="title">CutPolygon</span><span class="params">(Polygon poly,Point A,Point B)</span></span>&#123;</span><br><span class="line">    Polygon newpoly;</span><br><span class="line">    <span class="keyword">int</span> n=poly.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        Point C=poly[i],D=poly[(i+<span class="number">1</span>)%n];<span class="comment">//逆时针考虑多边形的所有顶点 </span></span><br><span class="line">        <span class="keyword">if</span>(dcmp(Cross(B-A,C-A))&gt;=<span class="number">0</span>) newpoly.push_back(C);</span><br><span class="line">        <span class="keyword">if</span>(dcmp(Cross(B-A,C-D))!=<span class="number">0</span>)&#123;</span><br><span class="line">            Point ip=GetLineIntersection(A,B-A,C,D-C);</span><br><span class="line">            <span class="keyword">if</span>(OnSegment(ip,C,D)) newpoly.push_back(ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newpoly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h2><p>凸包上被两条平行直线卡住的点对互为对踵点，对踵点对的数量是$O(n)$的</p>
<p>旋转卡壳目的是求出凸包上所有的对踵点对</p>
<p> 给定 $n$ 个点，最远点对一定是凸包上的对踵点对</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="随机增量法"><a href="#随机增量法" class="headerlink" title="随机增量法"></a>随机增量法</h2><h3 id="最小圆覆盖"><a href="#最小圆覆盖" class="headerlink" title="最小圆覆盖"></a>最小圆覆盖</h3><h3 id="Voronoi图与Delaunay三角剖分"><a href="#Voronoi图与Delaunay三角剖分" class="headerlink" title="Voronoi图与Delaunay三角剖分"></a>Voronoi图与Delaunay三角剖分</h3><h2 id="公式与性质"><a href="#公式与性质" class="headerlink" title="公式与性质"></a>公式与性质</h2><h3 id="Pick公式"><a href="#Pick公式" class="headerlink" title="Pick公式"></a>Pick公式</h3><p>在格点图上，整点多边形的面积=内部整点个数+边上的整点个数/2−1</p>
<h3 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h3><p>简单多面体的顶点数V，面数F与棱数E之间存在如下关系</p>
<script type="math/tex; mode=display">V-E+F=2</script><p>特别的，在平面图上：点数V，将平面分成的互不联通的区域数F，边数E与联通块个数W之间，有</p>
<script type="math/tex; mode=display">V-E+F=1+W</script><h3 id="三角形的心"><a href="#三角形的心" class="headerlink" title="三角形的心"></a>三角形的心</h3><ul>
<li>外心：外接圆圆心，三条中垂线交点 </li>
<li>内心：内接圆圆心，三条角平分线交点 </li>
<li>重心：三条中线交点，注意其物理性质</li>
<li>垂心：三条垂线交点</li>
<li>旁心：一个外交平分线与另外两个内角平分线交点 </li>
</ul>
<p>平面多边形的重心：所以顶点x/y坐标的平均数</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[K-D Tree]]></title>
      <url>/K-D%20Tree.html</url>
      <content type="html"><![CDATA[<p>$K-D$  $Tree$是一种分割$k$维数据空间的数据结构，主要应用于多维空间关键数据的搜索</p>
<a id="more"></a>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p><br></p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>$K-D$  $Tree$中的一个节点储存了一个$K$维空间域和一个$K$维的点坐标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d:点各维坐标 mi:空间各维坐标的min mx:空间各维坐标的max c:左右儿子</span><br></pre></td></tr></table></figure>
<p>以下以$2-D$  $Tree$为例</p>
<h2 id="构树"><a href="#构树" class="headerlink" title="构树"></a>构树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmin(a,b) (a&gt;b?a=b:a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmax(a,b) (a&lt;b?a=b:a)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">abc</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ww[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> ww[x];&#125; </span><br><span class="line">&#125;a[N];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(abc x,abc y)&#123;<span class="keyword">return</span> x[D]&lt;y[D];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[x][<span class="number">0</span>]) cmin(mi[x][i],mi[c[x][<span class="number">0</span>]][i]),cmax(mx[x][i],mx[c[x][<span class="number">0</span>]][i]);</span><br><span class="line">        <span class="keyword">if</span>(c[x][<span class="number">1</span>]) cmin(mi[x][i],mi[c[x][<span class="number">1</span>]][i]),cmax(mx[x][i],mx[c[x][<span class="number">1</span>]][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span><span class="comment">//循环选取维度 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D=x;<span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    nth_element(a+l,a+m,a+r+<span class="number">1</span>);<span class="comment">//使用某一维坐标的中位数作为切分点 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) d[m][i]=mi[m][i]=mx[m][i]=a[m][i];</span><br><span class="line">    <span class="keyword">if</span>(l&lt;m) c[m][<span class="number">0</span>]=build(l,m<span class="number">-1</span>,x^<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;m) c[m][<span class="number">1</span>]=build(m+<span class="number">1</span>,r,x^<span class="number">1</span>);</span><br><span class="line">    update(m);<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="估价"><a href="#估价" class="headerlink" title="估价"></a>估价</h2><p>算出目标点到当前查询区域距离的下界或上界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now:需估价的矩形区域 P:目标点</span></span><br><span class="line"><span class="comment">//曼哈顿最小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">    ret+=max(mi[now][i]-P[i],<span class="number">0</span>);</span><br><span class="line">    ret+=max(P[i]-mx[now][i],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//曼哈顿最大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//欧几里得最小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//欧几里得最大</span></span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//同平衡树</span></span><br><span class="line">    <span class="keyword">if</span>(!now)&#123;now=++n;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) d[now][i]=mi[now][i]=mx[now][i]=P[i];<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">int</span> tmp=P[x]&gt;=d[now][x];</span><br><span class="line">    insert(c[now][tmp],x^<span class="number">1</span>);</span><br><span class="line">    update(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(d[now][<span class="number">0</span>]-P[<span class="number">0</span>])+<span class="built_in">abs</span>(d[now][<span class="number">1</span>]-P[<span class="number">1</span>]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=Dis(x),dl[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) dl[i]=c[x][i]?getdis(c[x][i]):INF;<span class="comment">//估价函数，走较优的子树</span></span><br><span class="line">    cmin(ans,tmp);tmp=dl[<span class="number">0</span>]&gt;=dl[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(dl[tmp]&lt;ans) query(c[x][tmp]),tmp^=<span class="number">1</span>;<span class="comment">//不能更新答案直接跳过</span></span><br><span class="line">    <span class="keyword">if</span>(dl[tmp]&lt;ans) query(c[x][tmp]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[生成树]]></title>
      <url>/%E7%94%9F%E6%88%90%E6%A0%91.html</url>
      <content type="html"><![CDATA[<p> 联通图$G$的生成树是包含$G$中所有顶点的极小连通子图</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li><p>切割性质：在各边边权均不相同时，对于连接图$G$中两个非空点集的最短边$e$，$G$的任意$MST$一定包含$e$</p>
</li>
<li><p>回路性质：在各边边权均不相同时，对于图$G$中的任意回路的最长边$e$，$G$的任意$MST$一定不包含$e$</p>
</li>
</ul>
<a id="more"></a>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>对所有边按权值排序，最初每个点都是一个联通块</p>
<p>贪心地合并连接不同联通块的边，并查集维护</p>
<p>$O(m\log m+m\alpha(n))$</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>$Dijkstra$算法的变形，可以堆优化<br>可以处理负权边</p>
<h3 id="增量最小生成树"><a href="#增量最小生成树" class="headerlink" title="增量最小生成树"></a>增量最小生成树</h3><p>在$MST$中新加入边$e=(u,v)$后，图中恰好包含一个环<br>根据回路性质，删掉$max(e,MST$中$(u,v))$即可</p>
<h3 id="最小瓶颈生成树"><a href="#最小瓶颈生成树" class="headerlink" title="最小瓶颈生成树"></a>最小瓶颈生成树</h3><p>最小化生成树中最大边权值<br>$MST$就是一棵最小瓶颈生成树</p>
<h3 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h3><p>次小生成树可以由$MST$加一条边再删一条边得到</p>
<p>枚举不在$MST$中的$m-n+1$条边作为加入的新边，做增量最小生成树</p>
<h2 id="最小树形图"><a href="#最小树形图" class="headerlink" title="最小树形图"></a>最小树形图</h2><p>给定一个有向带权图$G$和根节点$u$，找出一棵有向生成树，满足$u$的入度为$0$，其他结点入度均为$1$，且从$u$可以到达所有其他结点</p>
<h3 id="朱刘算法"><a href="#朱刘算法" class="headerlink" title="朱刘算法"></a>朱刘算法</h3><p>预处理：删除自环，判断根节点是否可以到达其他节点，不能的话无解</p>
<p>首先给所有非根结点选一条权最小的入边，并将这些入边的和累加入答案</p>
<p>如果没有环，现在所有的入边就构成了最小树形图</p>
<p>否则，将构成的环缩成一个点，注意n个点n条边只能构成一个最简单的环（因此不需要跑Tarjan强联通分量），找到上面的一个点，进行重标号即可</p>
<p>重复上述过程，直到没有环（显然只剩下一个点的时候也是没有环的）</p>
<p>但是这样是不对的……注意一个环中的某一个点x，再一次找x的最小入边的时候，根据流程要把x的最小入边的边权累加入答案，但是x原来的最小入边也累加入答案，显然这样是会重复的；那么不妨在缩点的时候让所有x的入边都减去当前x的最小入边，相当于去重</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dirtree</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) in[i]=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">        <span class="keyword">if</span>(e[i].u!=e[i].v&amp;&amp;e[i].w&lt;in[e[i].v])</span><br><span class="line">            pre[e[i].v]=e[i].u,in[e[i].v]=e[i].w;<span class="comment">//定入边</span></span><br><span class="line">        in[rt]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(in[i]==INF) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//判断无解 </span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) id[i]=vis[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j,i=<span class="number">1</span>;i&lt;=n;i++)&#123;    </span><br><span class="line">            tmp+=in[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i;vis[j]!=i&amp;&amp;!id[j]&amp;&amp;j!=rt;j=pre[j]) vis[j]=i;<span class="comment">//到根-&gt;环结束</span></span><br><span class="line">            <span class="comment">//如果j已有标号或j为根的话就说明i之前的并不是正常的环</span></span><br><span class="line">            <span class="keyword">if</span>(!id[j]&amp;&amp;j!=rt)&#123;</span><br><span class="line">                id[j]=++cnt;     </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=pre[j];k!=j;k=pre[k])<span class="comment">//重编号  </span></span><br><span class="line">                id[k]=cnt;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!cnt) <span class="keyword">return</span> tmp;<span class="comment">//已经无环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!id[i]) id[i]=++cnt;<span class="comment">//不在环中的单独点当作一个单点环处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            f=in[e[i].v];</span><br><span class="line">            e[i].u=id[e[i].u],e[i].v=id[e[i].v];<span class="comment">//注意这里要用编号</span></span><br><span class="line">            <span class="keyword">if</span>(e[i].u!=e[i].v) e[i].w-=f;    </span><br><span class="line">        &#125;    </span><br><span class="line">        n=cnt,rt=id[rt];<span class="comment">//！ </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(nm)$</p>
<h2 id="最小斯坦纳树"><a href="#最小斯坦纳树" class="headerlink" title="最小斯坦纳树"></a>最小斯坦纳树</h2><p>使得指定集合中的点联通且权值和最小的生成树</p>
<p>$f[u][i]$表示以$u$为根，指定集合中的点状态为$i$的最小代价</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">int</span> all=<span class="number">1</span>&lt;&lt;k;<span class="comment">//k:1~k为指定点集</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) f[i][<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;all;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=i;s;s=(s<span class="number">-1</span>)&amp;i)</span><br><span class="line">            f[u][i]=min(f[u][i],f[u][s]+f[u][i^s]);<span class="comment">//通过连通状态的子集进行转移</span></span><br><span class="line">        <span class="keyword">if</span>(f[u][i]&lt;INF) q.push(u),vis[u]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spfa(i);<span class="comment">//通过spfa松弛</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n3^k+cm2^k)$，其中$cm$为$spfa$的复杂度</p>
<h2 id="生成树计数"><a href="#生成树计数" class="headerlink" title="生成树计数"></a>生成树计数</h2><h3 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h3><h3 id="prufer序列"><a href="#prufer序列" class="headerlink" title="prufer序列"></a>prufer序列</h3>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 生成树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大路]]></title>
      <url>/%E5%A4%A7%E8%B7%AF.html</url>
      <content type="html"><![CDATA[<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>多源最短路径</p>
<p>本质上是$dp$</p>
<p>$f[k][i][j]$表示从$i$到$j$只经过编号$1…k$点的最短路,可以解决诸如按顺序加点的问题</p>
<p>需要考虑重边(边权取$min$)、自环(读入边后$w[i][i]=0$)</p>
<a id="more"></a>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>单源最短路径</p>
<p>标号设定算法，基于贪心思想，因此只适用于边权非负</p>
<p>两点最短路优化：$T$被标记后直接退出</p>
<p>$O((n+m)\log n)$ 堆优化</p>
<h3 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h3><p>单源最短路径</p>
<p>标号迭代算法，$Bellman-Ford$算法的队列优化，可以处理负权边</p>
<p>两点最短路优化：$if(d[u]&gt;=d[T])$  $continue;$</p>
<p>$SLF$优化：每次入队后，$if(d[q[head+1]]&gt;d[tail])$  $swap(q[head+1],q[tail]);$</p>
<p>$LLL$优化：每次$v$出队后,$if(d[v]&gt;$队列中所有$d$的平均值) $q[++tail]=v,continue ;$</p>
<p>$O(ke)$，其中$k$是一个与出题人$rp$非线性相关的常数</p>
<h3 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h3><p>使用$dfs$版$spfa$，比较科学</p>
<h3 id="最短路树-amp-图"><a href="#最短路树-amp-图" class="headerlink" title="最短路树&amp;图"></a>最短路树&amp;图</h3><ul>
<li><strong>case1:</strong>跑完最短路后记录一个点由那个点转移而来，形成一棵树</li>
<li><strong>case2</strong>:保留图中所有可能成为最短路的边，形成一个图</li>
</ul>
<p>分层图最短路中，同一层内的顺序可能会与最短路图中的点的拓扑序相关</p>
<h3 id="最短路计数"><a href="#最短路计数" class="headerlink" title="最短路计数"></a>最短路计数</h3><p>统计点对间的最短路条数，某条边经过的最短路径数，etc</p>
<p>Floyd可以方便地实现，当然Dijkstra也可以</p>
<h3 id="次短路"><a href="#次短路" class="headerlink" title="次短路"></a>次短路</h3><p>枚举在最短路上但不在次短路上的边</p>
<h3 id="k短路"><a href="#k短路" class="headerlink" title="k短路"></a>k短路</h3><p>$A*$算法</p>
<h3 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h3><h3 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h3><p>大概就是求出所有点对间的联通性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;N+5&gt; b[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(b[i][k]) b[i]|=b[k];</span><br></pre></td></tr></table></figure>
<h2 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h2><p><strong>欧几里得距离</strong>：两点间的真实距离<br><strong>曼哈顿距离</strong>：各维坐标差绝对值的和；各维度独立，可以分开处理<br><strong>切比雪夫距离</strong>：各维坐标差绝对值的最大值，坐标系旋转$45°$可以和曼哈顿距离互相转化<br><strong>汉明距离</strong>：两个字符串不同的位数</p>
<p><a href="https://wenku.baidu.com/view/fa7a264459eef8c75fbfb374.html" target="_blank" rel="noopener">各种距离</a></p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><h3 id="欧拉通路"><a href="#欧拉通路" class="headerlink" title="欧拉通路"></a>欧拉通路</h3><p>通过图中每条边一次且仅一次的路径</p>
<h4 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h4><p>无向联通图：图中只有0个或2个度为奇数的节点</p>
<p>有向联通图：有且仅有两个顶点：其中一个入度数比出度数大1，另一个入度数比出度数小1，其余的顶点入度数等于出度数</p>
<h3 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h3><p>通过图中每条边一次且仅一次并回到起点的路径</p>
<h4 id="判定-1"><a href="#判定-1" class="headerlink" title="判定"></a>判定</h4><p>无向联通图：图中所有节点度均为偶数</p>
<p>有向联通图：图中所有节点入度等于出度</p>
<h3 id="输出路径"><a href="#输出路径" class="headerlink" title="输出路径"></a>输出路径</h3><h3 id="哈密顿回路"><a href="#哈密顿回路" class="headerlink" title="哈密顿回路"></a>哈密顿回路</h3><p>从给定的起点到给定的终点经过图中所有点的路径</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 路径 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线性代数]]></title>
      <url>/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html</url>
      <content type="html"><![CDATA[<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>矩阵是一个向量集,描述一个线性变换</p>
<a id="more"></a>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul>
<li>加减：对应元素相加减</li>
<li>数乘：每个元素乘一个数</li>
<li>转置：将矩阵的行列交换</li>
<li><p>乘法：$A:m \times n$ 矩阵，$B:n \times p$ 矩阵，$C=AB:m \times p$ 矩阵<br> $C_{ij}=\sum\limits_{k=1}^{n}A_{ik}B_{kj}$</p>
<p>结合律：$(AB)C=A(BC)$<br>左分配律：$(A+B)C=AC+BC$<br>右分配律：$C(A+B)=CA+CB$<br>不满足交换律</p>
</li>
</ul>
<h3 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h3><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>对$n$阶方阵</p>
<p>$<br>\left[<br>\begin{matrix}<br>  a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\<br>  a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}\\<br>  \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>  a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\\<br>\end{matrix}<br>\right]<br>$ $=\sum\limits_{j_1…j_n}^{}(-1)^{r(j_1…j_n)}a_{1j_1}…a_{nj_n}$</p>
<p>其中$j_1…j_n$为n元排列<br>$r(j_1…j_n)$表示其中的逆序对个数</p>
<h3 id="特征值与特征向量-amp-特征多项式"><a href="#特征值与特征向量-amp-特征多项式" class="headerlink" title="特征值与特征向量&amp;特征多项式"></a>特征值与特征向量&amp;特征多项式</h3><p>Cayley–Hamilton 定理</p>
<h3 id="特殊的矩阵"><a href="#特殊的矩阵" class="headerlink" title="特殊的矩阵"></a>特殊的矩阵</h3><p>单位矩阵$E$</p>
<p>$<br> \left[<br> \begin{matrix}<br>   1 &amp; 0 &amp; 0 \\\<br>   0 &amp; 1 &amp; 0 \\\<br>   0 &amp; 0 &amp; 1<br>  \end{matrix}<br>  \right]<br>$          </p>
<p>若$AB=E$，则$A$、$B$互为逆矩阵</p>
<p>循环矩阵</p>
<p>$<br> \left[<br> \begin{matrix}<br>   1 &amp; 2 &amp; 3 \\\<br>   3 &amp; 1 &amp; 2 \\\<br>   2 &amp; 3 &amp; 1<br> \end{matrix}<br> \right]<br>$      </p>
<ol>
<li>循环矩阵的线性运算及乘积仍是循环矩阵</li>
<li>满足乘法交换律：$AB=BA$</li>
<li>循环矩阵的逆仍是循环矩阵</li>
</ol>
<h3 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h3><p>利用矩阵，可以将以下线性方程组</p>
<p>$a_{11}x_1+a_{12}x_2+ … + a_{1n}x_n=b_1$</p>
<p>$a_{21}x_1+a_{22}x_2+ … + a_{2n}x_n=b_2$</p>
<p>$\vdots $</p>
<p>$a_{n1}x_1+a_{n2}x_2+ … + a_{nn}x_n=b_n$</p>
<p>记作$Ax=b$</p>
<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>一般方程组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gauss</span><span class="params">()</span></span>&#123;<span class="comment">//A[i][n+1]：x-&gt;b的线性变换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> r=i;<span class="comment">//列主元：提高数值稳定性</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[r][i])&lt;<span class="built_in">fabs</span>(a[j][i])) r=j;</span><br><span class="line">        <span class="keyword">if</span>(r!=i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++) swap(a[i][j],a[r][j]);<span class="comment">//交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n+<span class="number">1</span>;j&gt;=i;j--)<span class="comment">//逆序保证精度</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++) <span class="keyword">if</span>(k!=i)</span><br><span class="line">                a[k][j]-=a[k][i]/a[i][i]*a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i][n+<span class="number">1</span>]/=a[i][i];<span class="comment">//回代</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异或方程组</p>
<p>一些地方简化了……</p>
<p>自由元</p>
<h3 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h3><p>$n$个线性无关的向量，通过线性组合可以表示出线性空间内任意一个向量</p>
<h3 id="模线性方程组"><a href="#模线性方程组" class="headerlink" title="模线性方程组"></a>模线性方程组</h3><p><a href="https://blog.sengxian.com/algorithms/linear-basis" target="_blank" rel="noopener">notes</a></p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字符串基础]]></title>
      <url>/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80.html</url>
      <content type="html"><![CDATA[<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><p><br></p>
<div class="note info"><p>$hash$思想在字符串上的应用</p></div>
<p>$hash(i)=(hash(i-1)*B+s[i])$%$P$<br>$B$：进制数 参考：$457,251,2333,149,373$<br>$P$：模数 参考：$987654323,666666667,23456789$</p>
<a id="more"></a>
<h2 id="姿势"><a href="#姿势" class="headerlink" title="姿势"></a>姿势</h2><p>双模、自然溢出<br>从$i$开始长为$len$子串的哈希值：$hash(i+len-1)-hash(i-1)*fac(len)$<br>$hash$+二分求$LCP$ </p>
<p><br></p>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p><br></p>
<div class="note info"><p>在文本串$S$中匹配模板串$T$</p></div>
<h2 id="next-函数"><a href="#next-函数" class="headerlink" title="next()函数"></a>next()函数</h2><p>$next(i)$表示状态$i$失配后应转移到的状态<br>具体来说，$next(i)$表示前$i$位串的前缀和后缀的最长匹配（不包括$i$）<br>预处理$next()$相当于$T$自我匹配<br>性质：若$next(i)!=0$，且$i$%$(i-next(i))=0$，则字符串前$i$位循环，循环节长度为$i-next(i)$，循环次数为$i/(i-next(i))$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">()</span></span>&#123;<span class="comment">//start with 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>]) j=nex[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        nex[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>]) j=nex[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==m) ans.push_back(i-m+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="扩展KMP算法"><a href="#扩展KMP算法" class="headerlink" title="扩展KMP算法"></a>扩展KMP算法</h1><p><br></p>
<div class="note info"><p>对文本串$S=|n|$和模板串$T=|m|$<br>记$ext(i)$表示$Suffix(S,i)$与$T$的$LCP$长度<br>若$ext(i)=m$，说明找到了一个$T$，因此将其视为$KMP$问题的扩展</p></div>
<h2 id="next-函数-1"><a href="#next-函数-1" class="headerlink" title="next()函数"></a>next()函数</h2><p>辅助数组$next(i)$表示$Suffix(T,i)$与$T$的$LCP$长度<br>预处理方法类似$KMP$，相当于$T$与自己做$exKMP$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">()</span></span>&#123;<span class="comment">//start with 1</span></span><br><span class="line">    <span class="keyword">int</span> mx=mxp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        mxp=mxp&gt;i?mxp:i;</span><br><span class="line">        nex[i]=min(mxp-i,nex[i+<span class="number">1</span>-mx]);</span><br><span class="line">        <span class="keyword">while</span>(T[nex[i]+<span class="number">1</span>]==T[nex[i]+i]) nex[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+nex[i]&gt;mxp) mx=i;</span><br><span class="line">        mxp=mx+nex[mx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exkmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx=mxp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        mxp=mxp&gt;i?mxp:i;</span><br><span class="line">        ext[i]=min(mxp-i,nex[i+<span class="number">1</span>-mx]);</span><br><span class="line">        <span class="keyword">while</span>(T[ext[i]+<span class="number">1</span>]==S[ext[i]+i]) ext[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+ext[i]&gt;mxp) mx=i;</span><br><span class="line">        mxp=mx+ext[mx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p><br></p>
<div class="note info"><p>储存一个字符串集合</p></div>
<p>让$LCP$相同的字符串共用结点，并在叶子结点上附加信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx s[i]-<span class="meta-string">'a'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!c[x][idx]) c[x][idx]=++tot;</span><br><span class="line">        x=c[x][idx];</span><br><span class="line">    &#125;</span><br><span class="line">    dang[x]=v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p><br></p>
<div class="note info"><p>在文本串$S$中匹配模板串集合$T={T_1,T_2,…,T_k}$</p></div>
<p>将模板串集合$T$建成一棵$Trie$树</p>
<h2 id="转移函数"><a href="#转移函数" class="headerlink" title="转移函数"></a>转移函数</h2><p>$trans(x,c)$为从状态$x$沿字符$c$的$Trie$边走到的点<br>$fail(x)$，失配函数，指向的点$y$满足：$str(y)$为$str(x)$的最长后缀</p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>按$bfs$序构造<br>假设已经得到了$fail(u)$，有$v=trans(u,c)$，现在求$fail(v)$<br>只需要从$u$的后缀中找到第一个有$c$的出边的点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfail</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    l=<span class="number">0</span>,q[r=<span class="number">1</span>]=<span class="number">0</span>,fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)&#123;  </span><br><span class="line">        <span class="keyword">int</span> x=q[++l];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)  </span><br><span class="line">            <span class="keyword">if</span>(c[x][i]) q[++r]=c[x][i],fail[c[x][i]]=!x?<span class="number">0</span>:c[fail[x]][i];  </span><br><span class="line">            <span class="keyword">else</span> c[x][i]=!x?<span class="number">0</span>:c[fail[x]][i];   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h1><p><br></p>
<div class="note info"><p>对于一个环状字符串，将其断开可以得到n个串，其中字典序最小的串称为最小表示</p></div>
<p>通过维护两个指针实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;k&lt;n&amp;&amp;s[i+k]==s[j+k];k++);</span><br><span class="line">        <span class="keyword">if</span>(k==n) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">if</span>(s[i+k]&gt;s[j+k]) i+=k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> j+=k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==j) j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(i,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> hash </tag>
            
            <tag> KMP </tag>
            
            <tag> Trie树 </tag>
            
            <tag> AC自动机 </tag>
            
            <tag> 最小表示法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[后缀三姐妹]]></title>
      <url>/%E5%90%8E%E7%BC%80%E4%B8%89%E5%A7%90%E5%A6%B9.html</url>
      <content type="html"><![CDATA[<h1 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h1><p><br></p>
<div class="note info"><p>$sa(i)$：排第$i$名的后缀<br>$rank(i)$：$Suffix(i)$在所有后缀中的名次</p></div>
<a id="more"></a>
<h2 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h2><div class="note success"><p>对每个字符开始的长度为$2^k$的子字符串进行排序，求出$rank()$，当$2^k&gt;n$后，此时的$rank()$便是最后的结果<br>每一次排序利用上次两个长度为$2^{k-1}$的字符串的$rank()$作为第一、第二关键字，进行基数排序</p></div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> (r[a]==r[b])&amp;&amp;(r[a+l]==r[b+l]);&#125;<span class="comment">//比较第一、二关键字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DA</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m=<span class="number">128</span>)</span></span>&#123;<span class="comment">//n+1并人工添加一个较小的字符以避免cmp越界 </span></span><br><span class="line">    <span class="keyword">int</span> i,k,p,*x=rk,*y=rk2;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) c[i]=<span class="number">0</span>;<span class="comment">//对长度为1的字符串基数排序</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) c[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--c[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;k&lt;&lt;=<span class="number">1</span>,m=p)&#123;<span class="comment">//max(rank())&lt;p</span></span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-k;i&lt;n;i++) y[p++]=i;<span class="comment">//不存在第二关键字的排在前面</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=k) y[p++]=sa[i]-k;<span class="comment">//利用上一次求得的SA对第二关键字排序</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) c[i]=<span class="number">0</span>;<span class="comment">//对第一关键字基数排序</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) c[x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--c[x[y[i]]]]=y[i];</span><br><span class="line">        swap(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i<span class="number">-1</span>],sa[i],k)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;<span class="comment">//rank()保存在x数组中，p=不同的字符串个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h2><p>$height(i)$：$LCP(Suffix(sa[i]),Suffix(sa[i-1]))$<br>$h(i)$：$height(rank[i])$<br>性质：</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>根据$h(i) \geq h(i-1)-1$逐一计算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calh</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rk[i++]]=k)</span><br><span class="line">        <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rk[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=height[i];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++)  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)  </span><br><span class="line">            f[i][j]=min(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=rk[a],y=rk[b];</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) swap(x,y);x++;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">log</span>(y-x+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> min(f[x][k],f[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h1><p><br></p>
<p>大力搞搞……</p>
<a class="btn" href="https://www.cnblogs.com/gaochundong/p/suffix_tree.html" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>notes</a>
<p><br></p>
<h1 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h1><p><br></p>
<h2 id="确定性有限状态自动机"><a href="#确定性有限状态自动机" class="headerlink" title="确定性有限状态自动机"></a>确定性有限状态自动机</h2><div class="note info"><p>$DFA$由以下$5$部分组成</p>
<ul>
<li>$alpha$：字符集</li>
<li>$state$：状态集合</li>
<li>$init$：初始状态集合</li>
<li>$end$：终止状态集合</li>
<li>$trans$：状态转移函数</li>
</ul>
<p>$DFA$的功能是识别字符串<br>$SAM$本质上是一个$DFA$，可以识别$S$的所有子串</p></div>
<h2 id="最简状态表示"><a href="#最简状态表示" class="headerlink" title="最简状态表示"></a>最简状态表示</h2><p>现在需要把$S$建成$SAM$<br>考虑最简单的实现方式：将每个后缀插入一颗$Trie$树<br>但是这样太$naive$了，我们考虑合并状态</p>
<h3 id="right"><a href="#right" class="headerlink" title="right()"></a>right()</h3><p>对于$S$的一个子串$s1$，$right(s1)=s1$在$S$中所有出现的结束位置集合<br>将所有$right()$集相同的状态合并</p>
<h3 id="新的状态"><a href="#新的状态" class="headerlink" title="新的状态"></a>新的状态</h3><p>考虑其与原先暴力表示状态的不同</p>
<ul>
<li>代表的子串：新的状态代表的子串为右端点相同，长度递增的多种子串，记长度区间为$[min(x),max(x)]$</li>
<li>结论：状态的$right()$集合可以构成一个树形结构的关系，称其为$fail$树<br> 其中状态$x$在树上的父亲$fa$满足：$right(fa)\nsupseteqq right(x)$，且$|right(fa)|$最小，并有$min(x)=max(fail(x))+1$</li>
<li>状态数：可以证明是线性的</li>
<li>性质：一个子串的出现次数，就是其对应状态的$right()$集大小</li>
</ul>
<h2 id="转移函数"><a href="#转移函数" class="headerlink" title="转移函数"></a>转移函数</h2><p>$trans(x,str)$为从状态$x$读入字符串$str$后到达的状态<br>记$ST(str)=trans(init,str)$</p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><h3 id="增量法"><a href="#增量法" class="headerlink" title="增量法"></a>增量法</h3><p>让新加入的子串都被状态代表，而且$trans$边能够正确转移</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=a[x],np=++tot,p=last;last=np;</span><br><span class="line">    step[np]=x;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;!ch[p][c];p=fail[p]) ch[p][c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p) fail[np]=root; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(step[p]+<span class="number">1</span>==step[q]) fail[np]=q; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;step[nq]=step[p]+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq],ch[q],<span class="keyword">sizeof</span>(ch[q]));</span><br><span class="line">            fail[nq]=fail[q],fail[np]=fail[q]=nq;</span><br><span class="line">            <span class="keyword">for</span>(;ch[p][c]==q;p=fail[p]) ch[p][c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 后缀 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线性规划与整数规划]]></title>
      <url>/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92.html</url>
      <content type="html"><![CDATA[<h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>最大化或最小化一个受限于一组有限的线性约束的线性函数</p>
<a id="more"></a>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="标准型"><a href="#标准型" class="headerlink" title="标准型"></a>标准型</h3><p>最大化$\quad \sum\limits_{j=1}^{n} c_jx_j$</p>
<p>满足约束$~$ $\sum\limits_{j=1}^{n} a_{ij}x_j \le b_i,\ i=1,2,…,m$</p>
<p>$~$ $~$ $~$ $~$ $~$ $~$ $~$ $x_j \ge 0,\ j=1,2,…,n$</p>
<p>矩阵表示：${Max\ c^Tx\ :\ Ax \le b,\ x \ge 0}$</p>
<h4 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h4><ul>
<li>若目标函数要求取最小值，可以取相反数变成取最大值</li>
<li>对于限制条件$f(x_1,x_2,…,x_n)\geq b$，可以用不等式$-f(x_1,x_2,…,x_n)\leq -b$描述</li>
<li>对于限制条件$f(x_1,x_2,…,x_n)=b$，可以用两个不等式$f(x_1,x_2,…,x_n)\leq b$，$f(x_1,x_2,…,x_n)\geq b$描述</li>
<li>对于无限制的变量$x$，可以将其拆成两个非负变量$x_0$，$x_1$，使得$x=x_0-x_1$</li>
</ul>
<h3 id="松弛型"><a href="#松弛型" class="headerlink" title="松弛型"></a>松弛型</h3><p>最大化$\quad \sum\limits_{j=1}^{n} c_jx_j$</p>
<p>满足约束$~$ $x_{i+n}=b_i - \sum\limits_{j=1}^{n} a_{ij}x_j,~i=1,2,…,m$<br>$~$ $~$ $~$ $~$ $~$ $~$ $~$ $x_j \ge 0,\ j=1,2,…,n+m$</p>
<p><strong>基变量</strong>：等式左侧的所有变量<br><strong>非基变量</strong>：等式右侧的所有变量</p>
<h2 id="单纯性法"><a href="#单纯性法" class="headerlink" title="单纯性法"></a>单纯性法</h2><p>通过变量的代换，实现在解空间内沿着边界朝着目标函数增大的方向移动</p>
<p><strong>基本解</strong>：非基变量值为$0$，基变量值为$b_i$<br><strong>可行解</strong>：使得$m$个限制条件能够满足的一组非基变量</p>
<h3 id="转轴"><a href="#转轴" class="headerlink" title="转轴"></a>转轴</h3><p>选择一个基变量$X_l$，将其与非基变量$X_e$互换<br>根据$Bland$法则，选择系数大于$0$且标号最小的非基变量</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>如果基本解不是可行解，即存在$b_i&lt;0$<br>在所有$bi&lt;0$的约束中随机选一个作为$xl$，再随机选一个$a_{le}&lt;0$的作为$x_e$，然后$Pivot(l,e)$后$b_i$就变正了</p>
<h2 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h2><p>${Max\ c^Tx\ :\ Ax \le b,\ x \ge 0}\ \quad {Min b^Ty\ :\ A^Ty \ge c,\ t \ge 0}$</p>
<p>最大化最小化互换，常数与目标函数互换，改变不等号，变量与约束对应</p>
<h2 id="Sth"><a href="#Sth" class="headerlink" title="Sth"></a>Sth</h2><ol>
<li>当只有两个变量时，解空间为约束条件的半平面交，可以在半平面交上二分求解</li>
<li>单纯性法在一般情况下可以在多项式时间内出解，当然存在最坏情况可以被卡到指数复杂度</li>
</ol>
<h2 id="全幺模矩阵"><a href="#全幺模矩阵" class="headerlink" title="全幺模矩阵"></a>全幺模矩阵</h2><p>全幺模矩阵是指一个满足：任意一个行数和列数相等的满秩子矩阵行列式的值都是$1$或$-1$的矩阵</p>
<h3 id="充分条件"><a href="#充分条件" class="headerlink" title="充分条件"></a>充分条件</h3><ol>
<li><p>仅有$-1,0,1$构成</p>
</li>
<li><p>每列至多两个非零数</p>
</li>
<li><p>行可分为两个集合：</p>
<p>一列包含两个同号非零数，两行不在同一个集合</p>
<p>一列包含两个异号非零数，两行在同一个集合</p>
</li>
</ol>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>若线性规划中$A$为全幺模矩阵，则单纯形法过程中所有系数$∈−1,0,1$</p>
<p>能转化成全幺模矩阵的整数规划问题可以使用相同的线性规划解决</p>
<h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><p>整数规划指最后解中的变量都必须是整数的线性规划</p>
<p>$NP-hard$问题</p>
<h3 id="0-1-分数规划"><a href="#0-1-分数规划" class="headerlink" title="0-1 分数规划"></a>0-1 分数规划</h3><p>整数规划的特殊形式，即每个变量$x \in ${$0,1$}</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[各种图]]></title>
      <url>/%E5%90%84%E7%A7%8D%E5%9B%BE.html</url>
      <content type="html"><![CDATA[<h2 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h2><p>如果一个有向图无法从某个顶点出发经过若干条边回到该点，则这个图是一个有向无环图<br>$DAG$的生成树个数等于入度非零节点的入度积</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>$DAG$顶点的线性序列</p>
<a id="more"></a>
<h2 id="补图"><a href="#补图" class="headerlink" title="补图"></a>补图</h2><p>将完全图去除图$G$的边集后得到的图</p>
<h2 id="反向图"><a href="#反向图" class="headerlink" title="反向图"></a>反向图</h2><p>将有向图$G$的边反向后得到的图</p>
<h2 id="分层图"><a href="#分层图" class="headerlink" title="分层图"></a>分层图</h2><p>状态多维，层之间拓扑有序</p>
<p><a href="http://blog.csdn.net/creationaugust/article/details/44311285" target="_blank" rel="noopener">links</a></p>
<h2 id="平面图-amp-对偶图"><a href="#平面图-amp-对偶图" class="headerlink" title="平面图&amp;对偶图"></a>平面图&amp;对偶图</h2><p>可以画在平面上且边只在顶点处相交的图称为平面图</p>
<p>平面图的对偶图是将这个平面的每个区域看成点，原图每一条边所属的两个相邻的区域对应在对偶图中的点有连边</p>
<p><a href="http://blog.miskcoo.com/2015/05/planar-graph-dual-and-point-locate" target="_blank" rel="noopener">links</a></p>
<h2 id="竞赛图"><a href="#竞赛图" class="headerlink" title="竞赛图"></a>竞赛图</h2><p>将一个完全无向图的边定向后得到的有向图</p>
<h3 id="兰道定理"><a href="#兰道定理" class="headerlink" title="兰道定理"></a>兰道定理</h3><p>比分序列：把竞赛图每一个点的出度从小到大排列得到的序列<br>一个长度为$n$的序列$s$$(s_1≤s_2≤…≤s_n,n≥1)$是合法的比分序列当且仅当</p>
<script type="math/tex; mode=display">{\forall}1\leq k \leq n~,~\sum\limits_{i=1}^{k}s_i \geq {k\choose2}</script><p>特别地，当$k=n$时式子取等号</p>
<h2 id="区间图-amp-弦图-amp-完美图"><a href="#区间图-amp-弦图-amp-完美图" class="headerlink" title="区间图&amp;弦图&amp;完美图"></a>区间图&amp;弦图&amp;完美图</h2><p>弦：连接环中不相邻的两个点的边</p>
<p>弦图：</p>
<p>完美消除序列：</p>
<p>定理：一个无向图是弦图当且仅当它有一个完美消除序列</p>
<p>最大势算法：</p>
<p><a href="http://blog.csdn.net/qq_20118433/article/details/44420099" target="_blank" rel="noopener">lk1</a></p>
<p><a href="https://wenku.baidu.com/view/6f9f2223dd36a32d73758126.html" target="_blank" rel="noopener">lk2</a></p>
<h2 id="仙人掌图"><a href="#仙人掌图" class="headerlink" title="仙人掌图"></a>仙人掌图</h2><p>如果无向联通图$G$的任意一条边最多属于一个简单环，称$G$为仙人掌</p>
<p>简单环：不经过重复结点的环</p>
<p>祭出神图</p>
<p><img src="/img/what-is-cactus.png" width="90%" height="90%"></p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 理性愉悦 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图的连通性]]></title>
      <url>/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7.html</url>
      <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="联通分量"><a href="#联通分量" class="headerlink" title="联通分量"></a>联通分量</h3><p>在无向图中，可达关系满足自反性，对称性和传递性，是一个等价关系<br>从等价关系可以定义等价类，把相互可达的节点称为一个联通分量</p>
<a id="more"></a>
<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><h3 id="割点和桥"><a href="#割点和桥" class="headerlink" title="割点和桥"></a>割点和桥</h3><p>如果删除某个点$x$后，$G$的联通分量数目增加，称$x$为图的割点<br>如果删除某条边$E$后，$G$的联通分量数目增加，称$E$为图的桥</p>
<p>$x$为割点的条件<br>$x$是dfs树的根，且x有两个及以上子节点<br>$x$非根，且$x$存在子节点$v$，满足$low[v]\geq dfn[x]$</p>
<p>$E=(u,v)$为桥的条件<br>$E$不存在重边<br>满足$low[v]&gt; dfn[x]$</p>
<h3 id="点双联通分量"><a href="#点双联通分量" class="headerlink" title="点双联通分量"></a>点双联通分量</h3><p>若$G$中无割点，称$G$为点双连通图。$G$中任意两点间存在至少两条不经过重复点的路径<br>若$G$中无桥，称$G$为边双连通图。$G$中任意两点间存在至少两条不经过重复边的路径<br>除了桥外，每条边恰好属于一个边双联通分量，但不同点双联通分量可能会有公共点，可以证明公共点最多只有一个且为割点</p>
<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><p>若$G$中任意两点可达，称$G$为强连通图<br>对$SCC$缩点后原图变为$DAG$</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 连通性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[欧几里得相关]]></title>
      <url>/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%9B%B8%E5%85%B3.html</url>
      <content type="html"><![CDATA[<h2 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h2><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>不断将两数规模变小，直到能直接判断解<br>依据：$gcd(a,b)=gcd(b,a$%$b)，gcd(a,0)=a$<br>递归次数最多的是斐波那契数$f(n)$和$f(n-1)$</p>
<p>$O(logn)$</p>
<a id="more"></a>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>记$d=gcd(a,b)$，求出$ax+by=d$的一组解$(x,y)$，保证满足$|x|+|y|$最小<br>其任意解为$(x+kb’,y-ka’)$，$a’=a/d$，$b’=b/d$，$k$取任意整数<br>对于一般的线性方程$ax+by=c$，若$!(d|c)$则无解，否则$x \times \frac{c}{d}$，$y \times \frac{c}{d}$即可</p>
<p>$O(logn)$</p>
<h2 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a>类欧几里得算法</h2><h3 id="形式1"><a href="#形式1" class="headerlink" title="形式1"></a>形式1</h3><p>$f(a,b,c,n)=\sum\limits_{i=0}^n \lfloor \frac{ai+b}{c}\rfloor$</p>
<p>当$a\geq c$或$b \geq  c$时<br>$f(a,b,c,n)=$$\frac{n(n+1)}{2}\lfloor\frac{a}{c}\rfloor+(n+1)\lfloor\frac{b}{c}\rfloor+f(a$%$c,b$%$c,c,n)$</p>
<p>当$a&lt;c$且$b&lt;c$时<br>令$m= \lfloor \frac{an+b}{c}\rfloor$<br>$f(a,b,c,n)=$$nm-f(c,c-b-1,a,m-1)$</p>
<p><a href="http://blog.csdn.net/WorldWide_D/article/details/54730588" target="_blank" rel="noopener">推导</a></p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 欧几里得 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络流]]></title>
      <url>/%E7%BD%91%E7%BB%9C%E6%B5%81.html</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>$V$：点集 $E$：边集</p>
<p>$G=(V,E)$：图</p>
<p>$S$：源点  $T$：汇点</p>
<p>对于每条边$(u,v)$，有容量$c(u,v)$和流量$f(u,v)$，满足$0\leq f(u,v) \leq c(u,v)$</p>
<a id="more"></a>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>$1、$容量限制：$f(u,v)&lt;=c(u,v)$</p>
<p>$2、$反对称性：$f(u,v)=-f(v,u)$</p>
<p>$3、$流量平衡：$\sum f(u,i)=\sum f(i,v)$</p>
<p>满足以上三个性质，称为可行流</p>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><p>流量最大的可行流</p>
<h4 id="残量网络"><a href="#残量网络" class="headerlink" title="残量网络"></a>残量网络</h4><p>定义残量网络的流量$r(u,v)=c(u,v)-f(u,v)$</p>
<p>即一条弧还能流过的流量</p>
<h4 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h4><p>残量网络中一条由$S$到$T$的路径</p>
<h5 id="增广路定理：设-flow-是-G-的一个可行流，若不存在增广路，-flow-即为最大流"><a href="#增广路定理：设-flow-是-G-的一个可行流，若不存在增广路，-flow-即为最大流" class="headerlink" title="增广路定理：设$flow$是$G$的一个可行流，若不存在增广路，$flow$即为最大流"></a>增广路定理：设$flow$是$G$的一个可行流，若不存在增广路，$flow$即为最大流</h5><h4 id="前向弧-amp-后向弧"><a href="#前向弧-amp-后向弧" class="headerlink" title="前向弧&amp;后向弧"></a>前向弧&amp;后向弧</h4><p>分别表示残量网络与退流网络</p>
<h4 id="增流-amp-退流"><a href="#增流-amp-退流" class="headerlink" title="增流&amp;退流"></a>增流&amp;退流</h4><p>推进和修正流量</p>
<h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><p>最大流的正确性依赖于它的每一条 $S-T$ 流都与一种实际方案一一对应</p>
<h3 id="Isap算法"><a href="#Isap算法" class="headerlink" title="Isap算法"></a>Isap算法</h3><h4 id="marks"><a href="#marks" class="headerlink" title="marks"></a>marks</h4><p>$1.d[i]$：$i$到$T$的最短距离，可以$bfs$预处理(似乎没有并什么用)<br>$2.GAP$优化：当$S$和$T$不联通时不存在增广路，可以直接退出循环<br>$num[x]$表示$d[i]=x$的节点数量，初始化$num[0]=$总节点数<br>$3.$当前弧优化：保存一个点已经尝试过的邻接边<br>之前处理过的邻接边是不需要重新处理的(残量网络中的边只会越来越少)<br>$last[i]$表示当前弧的编号</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>上界：$O(n^2m)$<br>容量均为1：$O(min(n^{2/3},m^{1/2})*m)$<br>二分图：$O(\sqrt{n} m)$</p>
<p><a href="http://www.renfei.org/blog/isap.html" target="_blank" rel="noopener">详解</a></p>
<h3 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h3><p>每条边除流量限制外还有费用$c$，每流一个单位流量就要增加$c$的费用</p>
<p>一般是最小费用最大流或最小费用可行流</p>
<p>$spfa$单/多路增广</p>
<h3 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h3><h4 id="割"><a href="#割" class="headerlink" title="割"></a>割</h4><p>边集$C$使得$V$中的点分为两部分</p>
<h4 id="割的容量"><a href="#割的容量" class="headerlink" title="割的容量"></a>割的容量</h4><p>割中弧的流量总和</p>
<h4 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h4><p>一个$S-T$流的最大流等于其$S-T$最小割的容量</p>
<h4 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h4><p>跑出最大流后，在残量网络上跑$Tarjan$，求$SCC$</p>
<ul>
<li>一条满流边$(u,v)$可以出现在最小割集中，当且仅当$u$,$v$不在一个$SCC$中</li>
<li>一条满流边$(u,v)$必定出现在最小割集中，当且仅当$u$与$S$在一个$SCC$里，并且$v$与$T$在一个$SCC$里</li>
<li>易知$S$与$T$一定不在一个$SCC$中</li>
</ul>
<h4 id="最小割树"><a href="#最小割树" class="headerlink" title="最小割树"></a>最小割树</h4><p>任意两点之间的最小割，不同的只有$n-1$个，它们构成一个最小割树</p>
<p>定理$1$：$mincut(a,b)\geq min${$mincut(a,c_1),mincut(c_1,c_2),…,mincut(c_k,b)$}<br>定理$2$：令$(s,t)$是$(u,v)$在树上简单路径的所有边中$mincut$最小的，那么$mincut(u,v)=mincut(s,t)$</p>
<h5 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h5><ul>
<li>随便找两个点作为$S$和$T$，跑$mincut$</li>
<li>dfs划分出$S$集和$T$集，更新答案</li>
<li>递归处理$S$集和$T$集</li>
</ul>
<h2 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>无源汇<br>除$S$、$T$都要求满足流量平衡</p>
</li>
<li><p>有源汇<br>所有点都要求满足流量平衡</p>
</li>
</ul>
<h3 id="无源汇可行流"><a href="#无源汇可行流" class="headerlink" title="无源汇可行流"></a>无源汇可行流</h3><h4 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h4><ul>
<li>建立附加源点$ss$和附加汇点$tt$</li>
<li>连边：$(u,v,up-down)$</li>
<li>记$d(i)=\sum down(x,i)-\sum down(i,y)$</li>
<li>若$d(i)&gt;0$，连边$(ss,i,d(i))$，否则连边$(i,tt,-d(i))$</li>
</ul>
<h4 id="求解方法-1"><a href="#求解方法-1" class="headerlink" title="求解方法"></a>求解方法</h4><ul>
<li>跑$ss$到$tt$的最大流</li>
<li>若满流，那么一定存在一种可行流 </li>
<li>此时，原图中每一条边的流量应为新图中对应的边的流量$+down$</li>
</ul>
<h3 id="有源汇可行流"><a href="#有源汇可行流" class="headerlink" title="有源汇可行流"></a>有源汇可行流</h3><h4 id="建图-1"><a href="#建图-1" class="headerlink" title="建图"></a>建图</h4><ul>
<li>在原图中添加一条边$(T,S)$，流量限制为$[0,INF]$，即让$S$和$T$也满足流量平衡条件，改造成无源汇的网络流图</li>
</ul>
<h4 id="求解方法-2"><a href="#求解方法-2" class="headerlink" title="求解方法"></a>求解方法</h4><ul>
<li>同无源汇可行流</li>
</ul>
<h3 id="有源汇最大流"><a href="#有源汇最大流" class="headerlink" title="有源汇最大流"></a>有源汇最大流</h3><h4 id="建图-2"><a href="#建图-2" class="headerlink" title="建图"></a>建图</h4><ul>
<li>同有源汇可行流</li>
</ul>
<h4 id="求解方法-3"><a href="#求解方法-3" class="headerlink" title="求解方法"></a>求解方法</h4><ul>
<li>跑有源汇可行流</li>
<li>再跑一次$S$到$T$的最大流，即为答案</li>
</ul>
<h3 id="有源汇最小流"><a href="#有源汇最小流" class="headerlink" title="有源汇最小流"></a>有源汇最小流</h3><h4 id="建图-3"><a href="#建图-3" class="headerlink" title="建图"></a>建图</h4><ul>
<li>同无源汇可行流</li>
</ul>
<h4 id="求解方法-4"><a href="#求解方法-4" class="headerlink" title="求解方法"></a>求解方法</h4><ul>
<li>跑$ss$到$tt$的最大流</li>
<li>添加$(T,S)$，流量限制为$[0,INF]$</li>
<li>再跑一次$ss$到$tt$的最大流，判断是否存在可行流</li>
<li>答案即为$(T,S)$的实际流量</li>
</ul>
<h3 id="有源汇最小费用可行流"><a href="#有源汇最小费用可行流" class="headerlink" title="有源汇最小费用可行流"></a>有源汇最小费用可行流</h3><h4 id="建图-4"><a href="#建图-4" class="headerlink" title="建图"></a>建图</h4><ul>
<li>建立附加源点$ss$和附加汇点$tt$</li>
<li>连边：$(u,v,up-down,cost)$</li>
<li>记$d(i)=\sum down(x,i)-\sum down(i,y)$</li>
<li>若$d(i)&gt;0$，连边$(ss,i,d(i),0)$，否则连边$(i,tt,-d(i),0)$</li>
<li>添加$(T,S)$，流量限制为$[0,INF]$，费用为$0$</li>
</ul>
<h4 id="求解方法-5"><a href="#求解方法-5" class="headerlink" title="求解方法"></a>求解方法</h4><ul>
<li>跑$ss$到$tt$的最小费用最大流</li>
<li>答案即为（求出的费用+每条边的$down*cost$）</li>
</ul>
<h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><ol>
<li><p>多源多汇<br>增加超级源汇$S’$和$T’$<br>连边：$(S’,S,INF),(T,T’,INF)$</p>
</li>
<li><p>结点容量<br>设结点$x$的结点容量为$c$<br>将结点$x$拆成$x_{in}$和$x_{out}$<br>连边：$(x_{in},x_{out},c)$<br>把到达$x$的弧改为到达$x_{in}$,从$x$出发的弧改为从$x_{out}$出发</p>
</li>
<li><p>最大权闭合子图<br>从带点权图$G$中选出一个子图，对于$V$中任意一个结点，其后续节点都在$V$中，最大化$V$的权值和<br>连边：$(S,i,c_i),c_i&gt;0$，$(i,T,-c_i),c_i&lt;0$，$(u,v,INF)$<br>$ans=$正权点和-最小割</p>
</li>
<li><p>最大密度子图<br>从$G$中选出一个子图，最大化$\frac{|E|}{|V|}$<br>考虑$01$分数规划，二分答案为$k$<br>将边作为左侧顶点，权为$1$：点作为右侧顶点，权为$-k$<br>根据边和点的依赖关系转化成最大权闭合子图，$ans&gt;0$则增大$l$</p>
</li>
<li><p>最小割建图<br>先累加所有收益，再最小化舍弃值<br>一般拆成$S$集和$T$集考虑，对应两种选择。这样就会带来冲突，也就是需要割的边<br>$check$不同情况，检验建图正确性</p>
</li>
</ol>
<p><a href="http://www.cppblog.com/MatoNo1/archive/2012/05/11/174440.aspx" target="_blank" rel="noopener">Tips</a></p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul>
<li><p>枚举&amp;二分答案</p>
</li>
<li><p>合并流量<br>将起点终点相同的边流量累加起来</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二分图]]></title>
      <url>/%E4%BA%8C%E5%88%86%E5%9B%BE.html</url>
      <content type="html"><![CDATA[<p>把无向图$G$划分为两个不相交顶点集$U$和$V$，使得每一条边都分别连接$U$、$V$ 中的顶点，即不含有奇环的图</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h3><p>非联通图是二分图当且仅当其每个联通分量都是二分图</p>
<h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>边集$E$满足其中任意两条边没有公共顶点</p>
<h3 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h3><p>所有匹配中所含匹配边数最多的匹配</p>
<h3 id="完备匹配"><a href="#完备匹配" class="headerlink" title="完备匹配"></a>完备匹配</h3><p>某个匹配中所有的顶点都是匹配点</p>
<h3 id="最大权匹配"><a href="#最大权匹配" class="headerlink" title="最大权匹配"></a>最大权匹配</h3><p>带权二分图所有匹配中权值最大的匹配</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="最小点覆盖"><a href="#最小点覆盖" class="headerlink" title="最小点覆盖"></a>最小点覆盖</h3><p>选出一个点集，使每条边都有顶点在其中，且点数最少<br>最小点覆盖=最大匹配</p>
<h3 id="最小边覆盖"><a href="#最小边覆盖" class="headerlink" title="最小边覆盖"></a>最小边覆盖</h3><p>选出一个边集，使每个顶点都有边在其中，且边数最少<br>最小边覆盖=二分图点数-最大匹配</p>
<h3 id="最大点独立集"><a href="#最大点独立集" class="headerlink" title="最大点独立集"></a>最大点独立集</h3><p>选出一个点集，使所有点之间两两无边，且点数最多<br>最大点独立集=二分图点数-最大匹配</p>
<h3 id="最小路径覆盖"><a href="#最小路径覆盖" class="headerlink" title="最小路径覆盖"></a>最小路径覆盖</h3><p>在有向图$G$中用最少的不相交路径把图中所有点覆盖<br>拆点建二分图：对于$(x,y)$，连边$(x_1,y_2)$<br>最小路径覆盖=二分图点数-最大匹配</p>
<h3 id="最小链覆盖"><a href="#最小链覆盖" class="headerlink" title="最小链覆盖"></a>最小链覆盖</h3><p>在有向图$G$中用最少的路径把图中所有点覆盖<br>对$DAG$求出传递闭包后，问题转化为最小路径覆盖<br>最小链覆盖=二分图点数-最大匹配</p>
<h3 id="最长反链"><a href="#最长反链" class="headerlink" title="最长反链"></a>最长反链</h3><p>反链：点集$V$，对于$\forall (u,v)\in V$，满足$u$不能到达$v$且$v$不能到达$u$</p>
<p>$Dilworth$定理：最长反链=最小链覆盖</p>
<h3 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h3><p>选出一个点集，使所有点之间两两有边，且点数最多<br>最大团=补图的最大点独立集</p>
<p>以上推广到带权形式也是类似的</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[noip2016酱油记]]></title>
      <url>/noip2016%E9%85%B1%E6%B2%B9%E8%AE%B0.html</url>
      <content type="html"><![CDATA[<h2 id="Day-INF"><a href="#Day-INF" class="headerlink" title="Day -INF"></a>Day -INF</h2><p>大概前一个月开始翘部分晚自习，后来出去培训了一周，在校学习了一周，一共停课了两周，<del>每天都有新的收获，感觉信心满满</del>……变得更弱了</p>
<a id="more"></a>
<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>似乎是中午出发的，反正到日照一中已经很晚了……到了之后排了n长时间的队抽考场……抽之前希望在本校考（考点除了日照一中还有曲阜师范大学），抽完后发现在曲师，rp—，跟本校神犇连号，rp—……不过本校在曲师的人比较多，有教练带队……去宿舍只有上铺了……rp—，第一次睡上铺……<br>表示不会爬梯子……rp-=INF</p>
<h2 id="Day-0-5"><a href="#Day-0-5" class="headerlink" title="Day 0.5"></a>Day 0.5</h2><p>似乎看了看板子……反正非常颓……宿舍有人说话……差不多12点睡的觉</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>考场环境就不描述了，反正没出什么意外……<br>打开压缩包对着题目名字猜内容……rp—<br>密码为什么这么复杂啊……rp—<br>坐在menci斜对面，太强啦！，rp—</p>
<p>开始看题，第一题为什么这么长啊，花了很长时间读完后发现是sb题……<br>开始看第二题……瞬间吓尿了……完全不可做啊……这才是T2啊……<br>于是发现暴力lca只有25分，我当时lca还不太熟，感觉还需要调，就准备写20分特判……<br>看第三题发现是期望……感觉心态崩了……啥也不会……振作了一下后，发现28分不需要概率知识……</p>
<p>定下了100+20+28的目标，然后就码码码，但是我太弱了，T1还调试了一会……<br>完成计划后我又YY了一波T2的链部分分做法，GG<br>最后检查了一下出考场了</p>
<p>出考场后发现T3直接输出了int……丢掉了28分……心态再次爆炸</p>
<h2 id="Day-1-5"><a href="#Day-1-5" class="headerlink" title="Day 1.5"></a>Day 1.5</h2><p>舍友都出去颓了……我大概睡到了3点……睡醒后在校园里游荡，水SDOI群……<br>去洗了个澡冷静了一下……晚上仍然颓颓颓</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>在去考场的车上我复习了一下数论……我记得复习了一周以前刚学的杨辉三角……</p>
<p>看到T1秒想杨辉三角……似乎组合数我只学过这一个东西……<br>我看到T2范围这么大肯定不可做，于是看了看暴力分，我居然开始YY set做法……发现堆就可以了……其实堆暴力能过65，但是我连时间戳都不会打……只写了最暴力的25……我还花了一些时间脑补了一下隔几个输出是为什么……<br>T3完全不会，感觉要爆零……</p>
<p>看到T2、T3都这么神，我决定花大部分时间肛T1，争取A掉……我大概脑补了1个多小时，终于调好了……发现最后几组数据需要二维前缀和，我觉得我不太会就没加，然后写完T2 25分和T3 乱搞后大概还有半个小时</p>
<p>这时我去检查了一下T1，然后改错了……</p>
<p>我发现我的考试策略是非常正确的，<del>就是我太弱了……</del></p>
<p>回去的路上感觉只有200+（建立在T1能拿大部分分的基础上），感觉心情比较低落，毕竟以前1=最低也要300分</p>
<h2 id="Day-INF-1"><a href="#Day-INF-1" class="headerlink" title="Day INF"></a>Day INF</h2><p>上了几天课后期中考，翘掉考试去补课……补课期间某天晚上听说menci测的民间成绩我190……我看了一下程序发现day2T1挂掉了……过了几天出成绩了……<br>最后是100+20+0+25+25+5，成功滚粗</p>
]]></content>
      
        <categories>
            
            <category> 游记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> noip </tag>
            
            <tag> 滚粗 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
