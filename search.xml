<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[STL容器]]></title>
    <url>%2F2018%2F01%2F10%2FSTL%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[常数巨大(without O2) 动态内存,unfriendly for cena queue/stack/priority_queue123头文件:&lt;queue/stack&gt;定义:queue&lt;data&gt; x;小根堆:priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; 操作123x.push(key) x.pop(key)x.front() x.top()x.size() x.empty() pair12头文件:&lt;iostream&gt;定义:pair&lt;data,data&gt; x; 操作123.first .second//访问make_pair(x,y)//构造重载了&lt;，以first为第一关键字，second为第二关键字升序 set/multiset/hash_set/unordered_set123头文件:&lt;set/unordered_set&gt;//unordered_set was defined in C++11定义:set&lt;data&gt; x;迭代器:set&lt;data&gt;::iterator it; 操作1234567891011x.clear()x.insert(key)//插入一个值keyx.erase(key)//删除键值为key的元素(multiset会全部删除)x.erase(it)//删除迭代器为it的元素x.erase(l,r)//删除地址[l,r)的元素,l,r为两个迭代器指针x.begin() x.end()x.size() x.empty()x.find(key)//返回key的迭代器指针x.count(key)//返回键值等于key的元素的个数(multiset中使用)x.lower_bound(key)x.upper_bound(key) map/multimap/hash_map/unordered_map123头文件:&lt;map/unordered_map&gt;//unordered_map was defined in C++11定义:map&lt;data&gt; x;迭代器:map&lt;data&gt;::iterator it; 操作12345678910111213x.clear()mp[x]=key//插入元素it-&gt;first it-&gt;second//迭代器访问x.erase(key)//删除键值为key的元素(multimap会全部删除)x.erase(it)//删除迭代器为it的元素x.erase(l,r)//删除地址[l,r)的元素,l,r为两个迭代器指针x.swap(x2)//交换x,x2x.begin() x.end()x.size() x.empty()x.find(key)//返回key的迭代器指针x.count(key)//返回键值等于key的元素的个数(multimap中使用)x.lower_bound(key)x.upper_bound(key) 应用树套树（雾 vector123头文件:&lt;vector&gt;定义:vector&lt;data&gt; x;迭代器:vector&lt;data&gt;::iterator it; 操作1234567891011x.clear()x.push_back(key)x.insert(pos,key)//在迭代器指针pos处插入一个值keyx.erase(it)//删除迭代器为it的元素,use it=v.erase(it) instead of it++x.erase(l,r)//删除地址[l,r)的数，l,r为两个迭代器指针x.swap(x2)//交换x,x2x.reverse(l,r) 翻转地址[l,r)的数，l,r为两个迭代器指针x.begin() x.end()x.size() x.empty()x.lower_bound(key)x.upper_bound(key) string123头文件:&lt;string&gt;定义:string x;迭代器:string::iterator it; 操作12345678x.insert(pos,p)//在pos插入一个串px.erase(pos,l)//删除从pos开始l个位置x.replace(pos,l,s)//将从pos开始l个位置替换成串sx.length() x.size()x.substr(pos,l)//截取从pos开始，长为l的子串x.find(s2)//在s中匹配s2，返回位置，不存在返回-1，类似strstr&lt;&lt; &gt;&gt;输入输出流+ 拼接 &lt; 字典序 rope123头文件:&lt;ext/rope&gt;//can't be used in cena声明:using namespace __gnu_cxx;定义:crope x; 操作123456789x.push_back(ch)//在末尾添加字符chx.insert(pos,s)//在pos位置插入字符chx.erase(pos,x)//从pos位置开始删除x个字符x.replace(pos,ch)//将位置为pos的字符换成chx.substr(pos,x)//截取从pos开始，长为l的子串x.length() x.size()&lt;&lt; &gt;&gt;输入输出流-&gt;at(x)/[x]//访问+ 拼接 &lt; 字典序 应用区间翻转同时维护一正一反两个rope……反转即交换两个子串……Orz…… 区间循环位移拆成多个子串连起来就好了…… 可持久化1234//可持久化并查集fa[0]=new rope&lt;int&gt;(a,a+n+1);fa[i]=new rope&lt;int&gt;(*fa[i-1]);它可以实现O(1)的拷贝历史版本，由于rope的底层是平衡树，copy时copy根节点就行了用它就可以轻松实现可持久化数组 bitset12头文件:&lt;bitset&gt;定义:bitset&lt;M&gt; x;//M:长度 操作1234567x.set()//按位清1x.reset()//按位清0x.flip()//逐位取反x.any()//x中存在为1的二进制位返回1x.count()//x中为1的二进制位数x.to_ullong()//把x转为类型为unsigned long long的数支持位运算]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F01%2F09%2Ftest%2F</url>
    <content type="text"><![CDATA[qq forward stop arrows-alt arrows chevron-down chevron-left chevron-right chevron-up long-arrow-left long-arrow-down long-arrow-right long-arrow-up exchange link align-left rotate-right th-large table check-square circle circle-o cog spinner file-code-o plane rocket fighter-jet car thumbs-up question-circle-o warning unsorted toggle-on toggle-off star sort-amount-desc smile-o puzzle-piece others quote-left adjust ban book key question minus home globe commenting code cloud cube 调用Font Awesome 可以控制大小！ 人生乃是一面镜子， 从镜子里认识自己， 我要称之为头等大事， 也只是我们追求的目的！ 文本居中引用 note标签 default default 黑 primary 紫 success 绿 info 蓝 danger 红 warning 橙 带底色的块 danger no-icon 去掉+ note danger, note danger, note dangernote danger, note danger, note dangernote danger, note danger, note danger default name@文字 加底色 tabs 选项卡 1选项卡 2选项卡 3这是选项卡 1 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈…… 这是选项卡 2 这是选项卡 3 哇，你找到我了！φ(≧ω≦*)♪～ 然后上面源码中, 2表示一开始在第二个选项卡，非必须，若数值为-1则隐藏选项卡内容。更多用法请查看 Solution 2]]></content>
  </entry>
  <entry>
    <title><![CDATA[多项式与生成函数]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[多项式 表示系数表示法：$F(x)=\sum\limits_{i=0}^{n}a_ix^i$ 点值表示法：$(x_0,y_0),(x_1,y_1),\cdots,(x_n,y_n)$ 对于多项式$A(x)$，称其最高项的次数为这个多项式的度，记作$degA$ 运算多项式加减：采用系数表示法，进行向量加减 多项式乘法：采用点值表示法，将点的坐标相乘 快速傅里叶变换(FFT)基础知识部分待填坑 DTF：系数表示法-&gt;点值表示法逆DFT：点值表示法-&gt;系数表示法利用单位复数根的性质，可以在$O(n \log n)$的时间复杂度内完成 12345678910111213141516171819202122typedef complex&lt;double&gt; C;//复数库void pre()&#123; m=n&lt;&lt;1; for(n=1;n&lt;=m;n&lt;&lt;=1) L++; for(int i=0;i&lt;n;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1));//求逆序表：末位为0，直接为其前一半逆序表的值右移一位，末位为1，在最高位添加1&#125;void FFT(C *a,int f)&#123; for(int i=0;i&lt;n;i++) if(R[i]&gt;i) swap(a[i],a[R[i]]);//利用逆序表，快速求逆序 for(int i=1;i&lt;n;i&lt;&lt;=1)&#123; C wn(cos(pi/i),f*sin(pi/i)); for(int j=0;j&lt;n;j+=i&lt;&lt;1)&#123; C w(1,0);for(int k=0;k&lt;i;k++,w*=wn)&#123; C x=a[j+k],y=w*a[j+k+i]; a[j+k]=x+y;a[j+k+i]=x-y; &#125; &#125; &#125; if(f==-1) for(int i=0;i&lt;n;i++) a[i]/=n;&#125; 笔记 快速数论变换(NTT)FFT的缺点：常数大，炸精度，无法在模意义下求解 新的算法 数论意义下 一般模数$P=a \cdot 2^m +1,a$是一个较小的数 用原根代替单位复数根 笔记 快速沃尔什变换(FWT)大坑待填 笔记 多项式求逆对于多项式$A(x),B(x)$，存在唯一的$Q(x),R(x)$满足$A(x)=Q(x)B(x)+R(x)$，其中$degR&lt;degB$称$Q(x)$为$B(x)$除$A(x)$的商，$R(x)$为$B(x)$除$A(x)$的余数记作$A(x) \equiv R(x) \pmod {B(x)}$ 对于多项式$A(x)$，若存在$B(x)$满足$degB≤degA$，并且$A(x)B(x) \equiv 1 \pmod {x^n}$，那么称$B(x)$为$A(x)$在$mod$ $x^n$意义下的逆元，记作$A^{-1}(x)$ 采用倍增思想，设$B(x)$为$\bmod x^{\lceil \frac{n}{2} \rceil}$意义下$A(x)$的逆元 经过推导，最后可以得到 A^{-1}(x) \equiv 2B(x) - A(x)B^2(x) \pmod {x^n}递归$FFT$就可以搞了,同时易知多项式有逆元的充分必要条件为常数项有逆元 $O(n \log n)$，常数约为$FFT$的$6$倍 推导 多项式除法大坑待填 多项式取模大坑待填 牛顿迭代法给出$G(x)$，求$F(x)$，满足 G(f(x)) \equiv 0 \pmod {x^n} 多项式开方求$B^2(x) \equiv A(x) \pmod {x^n}$ 类似多项式求逆，设$B_0(x)$为$\bmod x^{\lceil \frac{n}{2} \rceil}$意义下$A(x)$的平方根 整理后得到 B(x)=\frac{B_0(x)+A(x)B_0^{-1}(x)}{2} \pmod {x^n}$O(n \log n)$ 多项式In求导…… 多项式exp取对数后使用牛顿迭代法 多项式k次幂…… 多项式复合…… 多项式多点求值与插值多点求值：给出多项式$A(x)$和$n$个点$x_0, x_1, \cdots, x_{n-1}$，要求求出$A(x_0)$, $A(x_1)$, $\cdots$, $A(x_{n-1})$ 插值：给出n+1个点$(x_0, y_0), (x_1, y_1), \cdots, (x_n, y_n)$，求出一个$n$次多项式，使得这些点都在这个多项式上 大力搞搞…… 参考资料Orz Miskcoo；Orz Miskcoo；Orz Candy? 总结1；总结2 生成函数 普通型生成函数定义序列$a_n$的普通型生成函数 (Ordinary Generating Function, OGF)，为 A(x)=\sum_\limits{i=0}^{}a_ix^i 指数型生成函数定义序列$a_n$的指数型生成函数 (Exponential Generating Function, EGF) ，为 A(x)=\sum_\limits{i=0}^{}a_i \frac{x^i}{i!}]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
</search>
