<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mmh&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/09a701bcc60a7d3dec73b55714f054e4</icon>
  <subtitle>And that has made all the difference</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mmh.ac.cn/"/>
  <updated>2018-01-11T13:51:16.308Z</updated>
  <id>http://mmh.ac.cn/</id>
  
  <author>
    <name>mmh</name>
    <email>815536154@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组合计数</title>
    <link href="http://mmh.ac.cn/2018/01/11/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    <id>http://mmh.ac.cn/2018/01/11/组合计数/</id>
    <published>2018-01-11T13:21:00.000Z</published>
    <updated>2018-01-11T13:51:16.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计数原理"><a href="#计数原理" class="headerlink" title="计数原理"></a>计数原理</h1><p><br></p><div class="note info"><p><strong>加法原理:</strong>做一件事情有$n$个办法，第$i$个办法有$p_i$种方案，则一共有$p_1+p_2+…+p_n$种方案</p><p><strong>乘法原理:</strong>做一件事情有$n$个步骤，第$i$个步骤有$p_i$种方案，则一共有$p_1 \times p_2 \times … \times p_n$种方案</p></div><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>先不考虑重叠的情况，计算出所有对象的数目，再把计数时重复计算的数目排斥出去</p><h2 id="鸽巢原理"><a href="#鸽巢原理" class="headerlink" title="鸽巢原理"></a>鸽巢原理</h2><p>把$n+1$个小球放进$n$个盒子，至少有一个盒子包含至少两个小球</p><p>一般形式：把$m$个小球放进$n$个盒子，至少有一个盒子包含至少$⌈m/n⌉$个小球</p><span class="label success">最差原则：考虑所有可能情况中，最不利于某件事情发生的情况</span><h2 id="Ramsey定理"><a href="#Ramsey定理" class="headerlink" title="Ramsey定理"></a>Ramsey定理</h2><p>将$6$个顶点的完全图的边用红、蓝两色任意着色，至少存在一个红色边三角形或蓝色边三角形</p><p><br></p><h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><p><br></p><h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>$n$个不同的数，选$k$个排成一排，每个数最多选一次</p><p>由乘法原理，$P(n,k)=\frac{n!}{(n-k)!}$</p><p>特别地，定义$0!=1$，$n$个数的全排列数$P(n,n)=n!$</p><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>$n$个不同的数，选$k$个(顺序无关)，每个数最多选一次</p><p>把$n$选$k$的排列问题分成两个步骤：</p><p>首先选出$k$个数的组合，然后把这$k$个数进行全排列</p><p>$C(n,k)=\frac{P(n,k)}{P(k,k)}=\frac{n!}{(n-k)!k!}$</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><div class="note success"><ol><li>$C(n,0)=C(n,n)=1$</li><li>$C(n,k)=C(n,n-k)$，$n$选$k$和$n$不选$k$的方案一一对应</li><li>$C(n,k)=C(n-1,k)+C(n-1,k-1)$，组合数递推公式，由加法原理推导出</li><li>二项式定理：$(a+b)^n=\sum\limits_{k=0}^{n} _{}^{}$</li></ol><p>note danger, note danger, note danger<br>note danger, note danger, note danger</p></div><h1 id="一些计数问题"><a href="#一些计数问题" class="headerlink" title="一些计数问题"></a>一些计数问题</h1><h1 id="等价类计数"><a href="#等价类计数" class="headerlink" title="等价类计数"></a>等价类计数</h1><h2 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h2><p>群论</p><p><a href="http://blog.csdn.net/xym_CSDN/article/details/53456447" target="_blank" rel="noopener">http://blog.csdn.net/xym_CSDN/article/details/53456447</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计数原理&quot;&gt;&lt;a href=&quot;#计数原理&quot; class=&quot;headerlink&quot; title=&quot;计数原理&quot;&gt;&lt;/a&gt;计数原理&lt;/h1&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;加法原理:&lt;/strong&gt;做一件事情
      
    
    </summary>
    
      <category term="笔记" scheme="http://mmh.ac.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="http://mmh.ac.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="组合计数" scheme="http://mmh.ac.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>高精度</title>
    <link href="http://mmh.ac.cn/2018/01/11/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <id>http://mmh.ac.cn/2018/01/11/高精度/</id>
    <published>2018-01-11T09:11:00.000Z</published>
    <updated>2018-01-11T09:16:53.257Z</updated>
    
    <content type="html"><![CDATA[<p>业界毒瘤<br>python大法好(雾</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rad 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 4<span class="comment">//int压4位</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bi</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2005</span>],l;</span><br><span class="line">    Bi()&#123;<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));l=<span class="number">1</span>;&#125;<span class="comment">//这里的memset可能会T……</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bi <span class="keyword">operator</span> + (Bi a,Bi b)&#123;</span><br><span class="line">    a.l=a.l&gt;b.l?a.l:b.l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a.l;i++)&#123;  </span><br><span class="line">    a.s[i]+=b.s[i];</span><br><span class="line">    <span class="keyword">if</span>(a.s[i]&gt;=rad) a.s[i]-=rad,a.s[i+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.s[a.l+<span class="number">1</span>]) a.l++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bi <span class="keyword">operator</span> - (Bi a,Bi b)&#123;<span class="comment">//大减小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a.l;i++)&#123;</span><br><span class="line">        a.s[i]-=b.s[i];</span><br><span class="line">        <span class="keyword">if</span>(a.s[i]&lt;<span class="number">0</span>) a.s[i]+=rad,a.s[i+<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a.l&gt;<span class="number">1</span>&amp;&amp;!a.s[a.l]) a.l--;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bi <span class="keyword">operator</span> * (Bi a,Bi b)&#123;<span class="comment">//暴力</span></span><br><span class="line">    Bi c;c.l=a.l+b.l<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a.l;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b.l;j++)</span><br><span class="line">            c.s[i+j<span class="number">-1</span>]+=a.s[i]*b.s[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c.l;i++)&#123;</span><br><span class="line">        c.s[i+<span class="number">1</span>]+=c.s[i]/rad;</span><br><span class="line">        c.s[i]%=rad;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c.s[c.l+<span class="number">1</span>]) c.l++;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bi <span class="keyword">operator</span> / (Bi a,<span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    Bi c;c.l=a.l;<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.l;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        k=k*rad+a.s[i];</span><br><span class="line">        c.s[i]=k/b;k%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.l&gt;<span class="number">1</span>&amp;&amp;!c.s[c.l]) c.l--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Bi x,Bi y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.l!=y.l) <span class="keyword">return</span> x.l&lt;y.l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x.l;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(x.s[i]!=y.s[i]) <span class="keyword">return</span> x.s[i]&lt;y.s[i];  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(Bi &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">strlen</span>(d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">        j=(l-i+B)/B,x.s[j]=x.s[j]*<span class="number">10</span>+d[i]-<span class="string">'0'</span>;</span><br><span class="line">    x.l=(l<span class="number">-1</span>+B)/B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Bi a)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,a.s[a.l]);<span class="keyword">for</span>(<span class="keyword">int</span> i=a.l<span class="number">-1</span>;i;i--) <span class="built_in">printf</span>(<span class="string">"%04d"</span>,a.s[i]);&#125;<span class="comment">//补0输出</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;业界毒瘤&lt;br&gt;python大法好(雾&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://mmh.ac.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础算法" scheme="http://mmh.ac.cn/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="高精度" scheme="http://mmh.ac.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>平衡树</title>
    <link href="http://mmh.ac.cn/2018/01/11/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <id>http://mmh.ac.cn/2018/01/11/平衡树/</id>
    <published>2018-01-11T03:11:00.000Z</published>
    <updated>2018-01-11T09:18:10.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sbt"><a href="#sbt" class="headerlink" title="sbt"></a>sbt</h1><div class="note info"><p>依靠size域维持平衡，对任意结点$x$满足<br>$size[rs[x]] \geq size[ls[ls[x]]],size[rs[ls[x]]]$<br>$size[ls[x]] \geq size[rs[rs[x]]],size[ls[rs[x]]]$</p></div><a id="more"></a><p><br></p><p>安利退化版sbt，<a href="https://wenku.baidu.com/view/5f94ff22192e45361066f5b1.html" target="_blank" rel="noopener">a short introduce</a><br>可能被卡（应该不会有人卡这个吧……）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种操作，与普通二叉查找树区别不大……</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> son(x,y) c[c[x][y]][y]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;sz[x]=sz[c[x][<span class="number">0</span>]]+sz[c[x][<span class="number">1</span>]]+<span class="number">1</span>;sum[x]=sum[c[x][<span class="number">0</span>]]+sum[c[x][<span class="number">1</span>]]+k[x];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> v)</span></span>&#123;x=++top,c[x][<span class="number">0</span>]=c[x][<span class="number">1</span>]=<span class="number">0</span>,sz[x]=<span class="number">1</span>,k[x]=v;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=c[x][k^<span class="number">1</span>];</span><br><span class="line">    c[x][k^<span class="number">1</span>]=c[y][k];</span><br><span class="line">    c[y][k]=x;pushup(y);</span><br><span class="line">    pushup(x);x=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) node(x,v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> m=v&gt;=k[x];<span class="comment">//这里把相同元素插入x的右子树 </span></span><br><span class="line">        insert(c[x][m],v);</span><br><span class="line">        <span class="keyword">if</span>(sz[son(x,m)]&gt;sz[c[x][m^<span class="number">1</span>]])<span class="comment">//维护平衡 </span></span><br><span class="line">        rotate(x,m^<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> y;  </span><br><span class="line">    <span class="keyword">if</span>(v&gt;k[x]) <span class="keyword">return</span> pre(c[x][<span class="number">1</span>],x,v);  </span><br><span class="line">    <span class="keyword">return</span> pre(c[x][<span class="number">0</span>],y,v);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> y;  </span><br><span class="line">    <span class="keyword">if</span>(v&lt;k[x]) <span class="keyword">return</span> suc(c[x][<span class="number">0</span>],x,v);  </span><br><span class="line">    <span class="keyword">return</span> suc(c[x][<span class="number">1</span>],y,v);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rk</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span><span class="comment">//求权值为x的排名 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v&gt;k[x]) <span class="keyword">return</span> sz[c[x][<span class="number">0</span>]]+<span class="number">1</span>+rk(c[x][<span class="number">1</span>],v);</span><br><span class="line">    <span class="keyword">return</span> rk(c[x][<span class="number">0</span>],v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=sz[c[x][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(w&lt;r) <span class="keyword">return</span> select(c[x][<span class="number">0</span>],w);</span><br><span class="line">    <span class="keyword">if</span>(w&gt;r) <span class="keyword">return</span> select(c[x][<span class="number">1</span>],w-r);</span><br><span class="line">    <span class="keyword">return</span> k[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> ;sz[x]--;sum[x]-=v;</span><br><span class="line">    <span class="keyword">if</span>(k[x]!=v) del(c[x][v&gt;k[x]],v);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l=c[x][<span class="number">0</span>],r=c[x][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(!l||!r) x=l+r;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(c[r][<span class="number">0</span>]) r=c[r][<span class="number">0</span>];<span class="comment">//乱搞删除</span></span><br><span class="line">            k[x]=k[r];</span><br><span class="line">            del(c[x][<span class="number">1</span>],k[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>,top=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="splay"><a href="#splay" class="headerlink" title="splay"></a>splay</h1><div class="note info"><p>依靠伸展操作维护平衡，复杂度可以势能分析证明<br>使被查询频率高的节点更靠近树根<br>常数巨大</p></div><p><br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LCT</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> c[fa[x]][<span class="number">1</span>]==x;&#125;<span class="comment">//指示方向</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isr</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> c[fa[x]][<span class="number">0</span>]!=x&amp;&amp;c[fa[x]][<span class="number">1</span>]!=x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> &amp;l=c[x][<span class="number">0</span>],&amp;r=c[x][<span class="number">1</span>];</span><br><span class="line">    rev[l]^=<span class="number">1</span>;rev[r]^=<span class="number">1</span>;swap(l,r);</span><br><span class="line">    rev[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=fa[x],g=fa[p],r;</span><br><span class="line">    <span class="keyword">bool</span> k=f(x),m=f(p);r=c[x][k^<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!isr(p)) c[g][m]=x;<span class="comment">//自上而下重新连接</span></span><br><span class="line">    fa[x]=g,c[x][k^<span class="number">1</span>]=p;</span><br><span class="line">    fa[p]=x,c[p][k]=r;</span><br><span class="line">    <span class="keyword">if</span>(r) fa[r]=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>;st[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;!isr(i);i=fa[i]) st[++top]=fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i;i--) pushdown(st[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    maintain(x);</span><br><span class="line">    <span class="keyword">for</span>(;!isr(x);rotate(x))</span><br><span class="line">     <span class="keyword">if</span>(!isr(fa[x])) rotate(f(x)==f(fa[x])?fa[x]:x);<span class="comment">//理性理解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="fhq-treap"><a href="#fhq-treap" class="headerlink" title="fhq treap"></a>fhq treap</h1><div class="note info"><p>每个结点有一个附加权，满足堆的性质<br>随机生产附加权，达到期望平衡<br>非旋转，可持久化</p></div><p><br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    pushdown(x);pushdown(y);</span><br><span class="line">    <span class="keyword">if</span>(rk[x]&lt;rk[y])</span><br><span class="line">    &#123;</span><br><span class="line">        c[x][<span class="number">1</span>]=merge(c[x][<span class="number">1</span>],y);</span><br><span class="line">        pushup(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c[y][<span class="number">0</span>]=merge(x,c[y][<span class="number">0</span>]);</span><br><span class="line">        pushup(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span><span class="comment">//按前k个分裂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) x=y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pushdown(now);</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=size[c[now][<span class="number">0</span>]])</span><br><span class="line">            y=now,split(c[now][<span class="number">0</span>],k,x,c[now][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x=now,split(c[now][<span class="number">1</span>],k-size[c[now][<span class="number">0</span>]]<span class="number">-1</span>,c[now][<span class="number">1</span>],y);</span><br><span class="line">        pushup(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://memphis.is-programmer.com/posts/46317.html" target="_blank" rel="noopener">link1</a><br><a href="http://www.yhzq-blog.cc/fhq-treap总结/" target="_blank" rel="noopener">link2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;sbt&quot;&gt;&lt;a href=&quot;#sbt&quot; class=&quot;headerlink&quot; title=&quot;sbt&quot;&gt;&lt;/a&gt;sbt&lt;/h1&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;依靠size域维持平衡，对任意结点$x$满足&lt;br&gt;$size[rs[x]] \geq size[ls[ls[x]]],size[rs[ls[x]]]$&lt;br&gt;$size[ls[x]] \geq size[rs[rs[x]]],size[ls[rs[x]]]$&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://mmh.ac.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="http://mmh.ac.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://mmh.ac.cn/tags/%E6%A0%91/"/>
    
      <category term="平衡树" scheme="http://mmh.ac.cn/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>STL容器</title>
    <link href="http://mmh.ac.cn/2018/01/10/STL%E5%AE%B9%E5%99%A8/"/>
    <id>http://mmh.ac.cn/2018/01/10/STL容器/</id>
    <published>2018-01-10T06:30:00.000Z</published>
    <updated>2018-01-10T11:10:12.244Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning"><ol><li>常数巨大(without O2)</li><li>动态内存,unfriendly for cena</li></ol></div><a id="more"></a><p><br></p><h1 id="queue-stack-priority-queue"><a href="#queue-stack-priority-queue" class="headerlink" title="queue/stack/priority_queue"></a>queue/stack/priority_queue</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">queue</span>/<span class="built_in">stack</span>&gt;</span><br><span class="line">定义:<span class="built_in">queue</span>&lt;data&gt; x;</span><br><span class="line">小根堆:priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.push(key) x.pop(key)</span><br><span class="line">x.front() x.top()</span><br><span class="line">x.size() x.empty()</span><br></pre></td></tr></table></figure><p><br></p><h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;iostream&gt;</span><br><span class="line">定义:pair&lt;data,data&gt; x;</span><br></pre></td></tr></table></figure><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.first .second<span class="comment">//访问</span></span><br><span class="line">make_pair(x,y)<span class="comment">//构造</span></span><br><span class="line">重载了&lt;，以first为第一关键字，second为第二关键字升序</span><br></pre></td></tr></table></figure><p><br></p><h1 id="set-multiset-hash-set-unordered-set"><a href="#set-multiset-hash-set-unordered-set" class="headerlink" title="set/multiset/hash_set/unordered_set"></a>set/multiset/hash_set/unordered_set</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">set</span>/<span class="built_in">unordered_set</span>&gt;<span class="comment">//unordered_set was defined in C++11</span></span><br><span class="line">定义:<span class="built_in">set</span>&lt;data&gt; x;</span><br><span class="line">迭代器:<span class="built_in">set</span>&lt;data&gt;::iterator it;</span><br></pre></td></tr></table></figure><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x.clear()</span><br><span class="line">x.insert(key)<span class="comment">//插入一个值key</span></span><br><span class="line">x.erase(key)<span class="comment">//删除键值为key的元素(multiset会全部删除)</span></span><br><span class="line">x.erase(it)<span class="comment">//删除迭代器为it的元素</span></span><br><span class="line">x.erase(l,r)<span class="comment">//删除地址[l,r)的元素,l,r为两个迭代器指针</span></span><br><span class="line">x.begin() x.end()</span><br><span class="line">x.size() x.empty()</span><br><span class="line">x.find(key)<span class="comment">//返回key的迭代器指针</span></span><br><span class="line">x.count(key)<span class="comment">//返回键值等于key的元素的个数(multiset中使用)</span></span><br><span class="line">x.lower_bound(key)</span><br><span class="line">x.upper_bound(key)</span><br></pre></td></tr></table></figure><p><br></p><h1 id="map-multimap-hash-map-unordered-map"><a href="#map-multimap-hash-map-unordered-map" class="headerlink" title="map/multimap/hash_map/unordered_map"></a>map/multimap/hash_map/unordered_map</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">map</span>/<span class="built_in">unordered_map</span>&gt;<span class="comment">//unordered_map was defined in C++11</span></span><br><span class="line">定义:<span class="built_in">map</span>&lt;data&gt; x;</span><br><span class="line">迭代器:<span class="built_in">map</span>&lt;data&gt;::iterator it;</span><br></pre></td></tr></table></figure><h2 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x.clear()</span><br><span class="line">mp[x]=key<span class="comment">//插入元素</span></span><br><span class="line">it-&gt;first it-&gt;second<span class="comment">//迭代器访问</span></span><br><span class="line">x.erase(key)<span class="comment">//删除键值为key的元素(multimap会全部删除)</span></span><br><span class="line">x.erase(it)<span class="comment">//删除迭代器为it的元素</span></span><br><span class="line">x.erase(l,r)<span class="comment">//删除地址[l,r)的元素,l,r为两个迭代器指针</span></span><br><span class="line">x.swap(x2)<span class="comment">//交换x,x2</span></span><br><span class="line">x.begin() x.end()</span><br><span class="line">x.size() x.empty()</span><br><span class="line">x.find(key)<span class="comment">//返回key的迭代器指针</span></span><br><span class="line">x.count(key)<span class="comment">//返回键值等于key的元素的个数(multimap中使用)</span></span><br><span class="line">x.lower_bound(key)</span><br><span class="line">x.upper_bound(key)</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>树套树（雾</p><p><br></p><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">vector</span>&gt;</span><br><span class="line">定义:<span class="built_in">vector</span>&lt;data&gt; x;</span><br><span class="line">迭代器:<span class="built_in">vector</span>&lt;data&gt;::iterator it;</span><br></pre></td></tr></table></figure><h2 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x.clear()</span><br><span class="line">x.push_back(key)</span><br><span class="line">x.insert(pos,key)<span class="comment">//在迭代器指针pos处插入一个值key</span></span><br><span class="line">x.erase(it)<span class="comment">//删除迭代器为it的元素,use it=v.erase(it) instead of it++</span></span><br><span class="line">x.erase(l,r)<span class="comment">//删除地址[l,r)的数，l,r为两个迭代器指针</span></span><br><span class="line">x.swap(x2)<span class="comment">//交换x,x2</span></span><br><span class="line">x.reverse(l,r) 翻转地址[l,r)的数，l,r为两个迭代器指针</span><br><span class="line">x.begin() x.end()</span><br><span class="line">x.size() x.empty()</span><br><span class="line">x.lower_bound(key)</span><br><span class="line">x.upper_bound(key)</span><br></pre></td></tr></table></figure><p><br></p><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">定义:<span class="built_in">string</span> x;</span><br><span class="line">迭代器:<span class="built_in">string</span>::iterator it;</span><br></pre></td></tr></table></figure><h2 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x.insert(pos,p)<span class="comment">//在pos插入一个串p</span></span><br><span class="line">x.erase(pos,l)<span class="comment">//删除从pos开始l个位置</span></span><br><span class="line">x.replace(pos,l,s)<span class="comment">//将从pos开始l个位置替换成串s</span></span><br><span class="line">x.length() x.size()</span><br><span class="line">x.substr(pos,l)<span class="comment">//截取从pos开始，长为l的子串</span></span><br><span class="line">x.find(s2)<span class="comment">//在s中匹配s2，返回位置，不存在返回-1，类似strstr</span></span><br><span class="line">&lt;&lt; &gt;&gt;输入输出流</span><br><span class="line">+ 拼接 &lt; 字典序</span><br></pre></td></tr></table></figure><p><br></p><h1 id="rope"><a href="#rope" class="headerlink" title="rope"></a>rope</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;ext/rope&gt;<span class="comment">//can't be used in cena</span></span><br><span class="line">声明:<span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line">定义:crope x;</span><br></pre></td></tr></table></figure><h2 id="操作-6"><a href="#操作-6" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x.push_back(ch)<span class="comment">//在末尾添加字符ch</span></span><br><span class="line">x.insert(pos,s)<span class="comment">//在pos位置插入字符ch</span></span><br><span class="line">x.erase(pos,x)<span class="comment">//从pos位置开始删除x个字符</span></span><br><span class="line">x.replace(pos,ch)<span class="comment">//将位置为pos的字符换成ch</span></span><br><span class="line">x.substr(pos,x)<span class="comment">//截取从pos开始，长为l的子串</span></span><br><span class="line">x.length() x.size()</span><br><span class="line">&lt;&lt; &gt;&gt;输入输出流</span><br><span class="line">-&gt;at(x)/[x]<span class="comment">//访问</span></span><br><span class="line">+ 拼接 &lt; 字典序</span><br></pre></td></tr></table></figure><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><h3 id="区间翻转"><a href="#区间翻转" class="headerlink" title="区间翻转"></a>区间翻转</h3><p>同时维护一正一反两个rope……反转即交换两个子串……Orz……</p><h3 id="区间循环位移"><a href="#区间循环位移" class="headerlink" title="区间循环位移"></a>区间循环位移</h3><p>拆成多个子串连起来就好了……</p><h3 id="可持久化"><a href="#可持久化" class="headerlink" title="可持久化"></a>可持久化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可持久化并查集</span></span><br><span class="line">fa[<span class="number">0</span>]=<span class="keyword">new</span> rope&lt;<span class="keyword">int</span>&gt;(a,a+n+<span class="number">1</span>);fa[i]=<span class="keyword">new</span> rope&lt;<span class="keyword">int</span>&gt;(*fa[i<span class="number">-1</span>]);</span><br><span class="line">它可以实现O(<span class="number">1</span>)的拷贝历史版本，由于rope的底层是平衡树，copy时copy根节点就行了</span><br><span class="line">用它就可以轻松实现可持久化数组</span><br></pre></td></tr></table></figure><p><br></p><h1 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">头文件:&lt;<span class="built_in">bitset</span>&gt;</span><br><span class="line">定义:<span class="built_in">bitset</span>&lt;M&gt; x;<span class="comment">//M:长度</span></span><br></pre></td></tr></table></figure><h2 id="操作-7"><a href="#操作-7" class="headerlink" title="操作"></a>操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="built_in">set</span>()<span class="comment">//按位清1</span></span><br><span class="line">x.reset()<span class="comment">//按位清0</span></span><br><span class="line">x.flip()<span class="comment">//逐位取反</span></span><br><span class="line">x.any()<span class="comment">//x中存在为1的二进制位返回1</span></span><br><span class="line">x.count()<span class="comment">//x中为1的二进制位数</span></span><br><span class="line">x.to_ullong()<span class="comment">//把x转为类型为unsigned long long的数</span></span><br><span class="line">支持位运算</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note warning&quot;&gt;&lt;ol&gt;
&lt;li&gt;常数巨大(without O2)&lt;/li&gt;
&lt;li&gt;动态内存,unfriendly for cena&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://mmh.ac.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="http://mmh.ac.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="STL" scheme="http://mmh.ac.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mmh.ac.cn/2018/01/09/test/"/>
    <id>http://mmh.ac.cn/2018/01/09/test/</id>
    <published>2018-01-09T07:35:46.274Z</published>
    <updated>2018-01-09T08:41:34.652Z</updated>
    
    <content type="html"><![CDATA[<p><i class="fa fa-download fa-2x"></i>  </p><p><i class="fa fa-qq"></i> qq</p><p><i class="fa fa-forward"></i> forward</p><p><i class="fa fa-stop"></i> stop</p><p><i class="fa fa-arrows-alt"></i> arrows-alt</p><p><i class="fa fa-arrows"></i> arrows</p><p><i class="fa fa-chevron-down"></i> chevron-down</p><p><i class="fa fa-chevron-left"></i> chevron-left</p><p><i class="fa fa-chevron-right"></i> chevron-right</p><p><i class="fa fa-chevron-up"></i> chevron-up</p><p><i class="fa fa-long-arrow-left"></i> long-arrow-left</p><p><i class="fa fa-long-arrow-down"></i> long-arrow-down</p><p><i class="fa fa-long-arrow-right"></i> long-arrow-right</p><p><i class="fa fa-long-arrow-up"></i> long-arrow-up</p><p><i class="fa fa-exchange"></i> exchange</p><p><i class="fa fa-link"></i> link</p><p><i class="fa fa-align-left"></i> align-left</p><p><i class="fa fa-rotate-right"></i> rotate-right </p><p><i class="fa fa-th-large"></i> th-large</p><p><i class="fa fa-table"></i> table</p><p><i class="fa fa-check-square"></i> check-square</p><p><i class="fa fa-circle"></i> circle</p><p><i class="fa fa-circle-o"></i> circle-o</p><p><i class="fa fa-cog"></i> cog</p><p><i class="fa fa-spinner"></i> spinner</p><p><i class="fa fa-file-code-o"></i> file-code-o</p><p><i class="fa fa-plane"></i> plane</p><p><i class="fa fa-rocket"></i> rocket</p><p><i class="fa fa-fighter-jet"></i> fighter-jet</p><p><i class="fa fa-car"></i> car</p><p><i class="fa fa-thumbs-up"></i> thumbs-up</p><p><i class="fa fa-question-circle-o"></i> question-circle-o</p><p><i class="fa fa-warning"></i> warning</p><p><i class="fa fa-unsorted "></i> unsorted </p><p><i class="fa fa-toggle-on"></i> toggle-on</p><p><i class="fa fa-toggle-off"></i> toggle-off</p><p><i class="fa fa-star"></i> star</p><p><i class="fa fa-sort-amount-desc"></i> sort-amount-desc</p><p><i class="fa fa-smile-o"></i> smile-o</p><p><i class="fa fa-puzzle-piece"></i> puzzle-piece</p><p>others </p><p><i class="fa fa-quote-left"></i> quote-left</p><p><i class="fa fa-adjust"></i> adjust</p><p><i class="fa fa-ban"></i> ban</p><p><i class="fa fa-book"></i> book</p><p><i class="fa fa-key"></i> key</p><p><i class="fa fa-question"></i> question</p><p><i class="fa fa-minus"></i> minus</p><p><i class="fa fa-home"></i> home</p><p><i class="fa fa-globe"></i> globe</p><p><i class="fa fa-commenting"></i> commenting</p><p><i class="fa fa-code"></i> code</p><p><i class="fa fa-cloud"></i> cloud</p><p><i class="fa fa-cube"></i> cube</p><p>调用<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">Font Awesome</a> </p><p>可以控制大小！</p><blockquote class="blockquote-center"><p>人生乃是一面镜子，</p><p>从镜子里认识自己，</p><p>我要称之为头等大事，</p><p>也只是我们追求的目的！</p></blockquote><p>文本居中引用</p><p>note标签</p><div class="note danger"><p>default</p></div><p>default 黑</p><p>primary 紫</p><p>success 绿</p><p>info 蓝</p><p>danger 红</p><p>warning 橙</p><p>带底色的块</p><div class="note danger no-icon"><p>danger no-icon</p></div><p>去掉+</p><div class="note danger"><p>note danger, note danger, note danger<br>note danger, note danger, note danger<br>note danger, note danger, note danger</p></div><span class="label default">default</span><p>name@文字</p><p>加底色</p><p>tabs</p><div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab active"><a href="#选项卡-2">选项卡 2</a></li><li class="tab"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p><strong>这是选项卡 1</strong> 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……</p></div><div class="tab-pane active" id="选项卡-2"><p><strong>这是选项卡 2</strong></p></div><div class="tab-pane" id="选项卡-3"><p><strong>这是选项卡 3</strong> 哇，你找到我了！φ(≧ω≦*)♪～</p></div></div></div><p>然后上面源码中<code>, 2</code>表示一开始在第二个选项卡，非必须，若数值为<code>-1</code>则隐藏选项卡内容。更多用法请查看 </p><div class="tabs" id="sixth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#sixth-unique-name-1"><i class="fa fa-text-width" "=""></i>Solution 1</a></li><li class="tab"><a href="#sixth-unique-name-2"><i class="fa fa-amazon" "=""></i>Solution 2</a></li><li class="tab"><a href="#sixth-unique-name-3"><i class="fa fa-bold" "=""></i>Solution 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane" id="sixth-unique-name-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-pane" id="sixth-unique-name-3"><p><strong>This is Tab 3.</strong></p></div></div></div><p>+icon</p><a class="btn" href="https://www.baidu.com" target="_blank" rel="noopener"><i class="fa fa-download fa-lg fa-fw"></i>点击下载百度</a><p>按钮</p><p>use icon</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;i class=&quot;fa fa-download fa-2x&quot;&gt;&lt;/i&gt;  &lt;/p&gt;
&lt;p&gt;&lt;i class=&quot;fa fa-qq&quot;&gt;&lt;/i&gt; qq&lt;/p&gt;
&lt;p&gt;&lt;i class=&quot;fa fa-forward&quot;&gt;&lt;/i&gt; forward&lt;/p&gt;
&lt;p&gt;&lt;i class=&quot;f
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二进制</title>
    <link href="http://mmh.ac.cn/2018/01/05/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>http://mmh.ac.cn/2018/01/05/二进制/</id>
    <published>2018-01-05T11:56:00.000Z</published>
    <updated>2018-01-11T10:27:02.883Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger"><p>位运算的优先级比较奇怪，请加括号使用</p></div><p>C/C++语言提供的位运算符</p><p><img src="/img/2.png" width="100%" height="100%"></p><a id="more"></a><p>用$x$表示一个10进制数，记其二进制展开从最右边开始为第$0、1、2…$位</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">语句</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">获取$x$的第$i$位</td><td style="text-align:center">x&amp;(1&lt;&lt;i)</td><td style="text-align:center">若$x$的第$i$位为$1$，值为$2^i$</td></tr><tr><td style="text-align:center">bar</td><td style="text-align:center">bar</td><td style="text-align:center">bar</td></tr><tr><td style="text-align:center">查询$x$中$1$的个数</td><td style="text-align:center">__builtin_popcount(x)</td><td style="text-align:center">GCC内建函数</td></tr><tr><td style="text-align:center">提取lowbit(x)</td><td style="text-align:center">x&amp;(-x)</td><td style="text-align:center">可以遍历$x$中所有$1$</td></tr></tbody></table></div><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">语句</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">判断奇偶性</td><td style="text-align:center">x&amp;1</td><td style="text-align:center">值为$1$则$x$为奇数</td></tr><tr><td style="text-align:center">乘除$2$</td><td style="text-align:center">&lt;&lt; &amp; &gt;&gt;</td><td style="text-align:center">根据实际意义</td></tr><tr><td style="text-align:center">对$2$的幂取模</td><td style="text-align:center">__builtin_popcount(x)</td><td style="text-align:center">GCC内建函数</td></tr><tr><td style="text-align:center">交换两个数</td><td style="text-align:center">a^=b,b^=a,a^=b</td><td style="text-align:center">根据实际意义</td></tr></tbody></table></div><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>用二进制数表示集合，设单个二进制数最大位宽为$w$</p><h3 id="修改-amp-查询-amp-删除"><a href="#修改-amp-查询-amp-删除" class="headerlink" title="修改&amp;查询&amp;删除"></a>修改&amp;查询&amp;删除</h3><p>直接上……</p><p>$O(1)$</p><h3 id="集合交-amp-并-amp-差-amp-补"><a href="#集合交-amp-并-amp-差-amp-补" class="headerlink" title="集合交&amp;并&amp;差&amp;补"></a>集合交&amp;并&amp;差&amp;补</h3><p>x&amp;y<br>x|y<br>x^(x&amp;y)<br>~x</p><p>$O(\frac{n}{w})$</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>位运算每一位相互独立，互不干扰，可以按位考虑，进行dp/贪心</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note danger&quot;&gt;&lt;p&gt;位运算的优先级比较奇怪，请加括号使用&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;C/C++语言提供的位运算符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2.png&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://mmh.ac.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="黑科技" scheme="http://mmh.ac.cn/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
      <category term="二进制" scheme="http://mmh.ac.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="位运算" scheme="http://mmh.ac.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>多项式与生成函数</title>
    <link href="http://mmh.ac.cn/2018/01/05/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    <id>http://mmh.ac.cn/2018/01/05/多项式与生成函数/</id>
    <published>2018-01-05T01:22:00.000Z</published>
    <updated>2018-01-10T13:06:57.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><p><br></p><h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><div class="note info"><p><strong>系数表示法</strong>：$F(x)=\sum\limits_{i=0}^{n}a_ix^i$</p><p><strong>点值表示法</strong>：$(x_0,y_0),(x_1,y_1),\cdots,(x_n,y_n)$</p><p>对于多项式$A(x)$，称其最高项的次数为这个多项式的<strong>度</strong>，记作$degA$</p></div><a id="more"></a><p><br></p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><div class="note info"><p><strong>多项式加减</strong>：采用系数表示法，进行向量加减</p><p><strong>多项式乘法</strong>：采用点值表示法，将点的坐标相乘</p></div><p><br></p><h3 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换(FFT)"></a>快速傅里叶变换(FFT)</h3><p>基础知识部分待填坑</p><div class="note info"><p><strong>DTF</strong>：系数表示法-&gt;点值表示法<br><strong>逆DFT</strong>：点值表示法-&gt;系数表示法<br>利用单位复数根的性质，可以在$O(n \log n)$的时间复杂度内完成</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; C;<span class="comment">//复数库</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>) L++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));<span class="comment">//求逆序表：末位为0，直接为其前一半逆序表的值右移一位，末位为1，在最高位添加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(C *a,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(R[i]&gt;i) swap(a[i],a[R[i]]);<span class="comment">//利用逆序表，快速求逆序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        C wn(cos(pi/i),f*sin(pi/i));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="function">C <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++,w*=wn)&#123;</span><br><span class="line">                C x=a[j+k],y=w*a[j+k+i];</span><br><span class="line">                a[j+k]=x+y;a[j+k+i]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]/=n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a class="btn" href="http://www.gatevin.moe/acm/fft算法学习笔记/" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>笔记</a><p><br></p><h3 id="快速数论变换-NTT"><a href="#快速数论变换-NTT" class="headerlink" title="快速数论变换(NTT)"></a>快速数论变换(NTT)</h3><div class="note danger"><p>FFT的缺点：常数大，炸精度，无法在模意义下求解</p></div><p><i class="fa fa-key"></i> 新的算法</p><div class="note success"><p>数论意义下</p><p>一般模数$P=a \cdot 2^m +1,a$是一个较小的数</p><p>用原根代替单位复数根</p></div><a class="btn" href="https://www.cnblogs.com/candy99/p/6641972.html算法学习笔记/" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>笔记</a><p><br></p><h3 id="快速沃尔什变换-FWT"><a href="#快速沃尔什变换-FWT" class="headerlink" title="快速沃尔什变换(FWT)"></a>快速沃尔什变换(FWT)</h3><p>大坑待填</p><a class="btn" href="http://picks.logdown.com/posts/179290-fast-walsh-hadamard-transform算法学习笔记/" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>笔记</a><p><br></p><h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h3><div class="note info"><p>对于多项式$A(x),B(x)$，存在唯一的$Q(x),R(x)$<br>满足$A(x)=Q(x)B(x)+R(x)$，其中$degR&lt;degB$<br>称$Q(x)$为$B(x)$除$A(x)$的<strong>商</strong>，$R(x)$为$B(x)$除$A(x)$的<strong>余数</strong><br>记作$A(x) \equiv R(x) \pmod {B(x)}$</p><p>对于多项式$A(x)$，若存在$B(x)$满足$degB≤degA$，<br>并且$A(x)B(x) \equiv 1 \pmod {x^n}$，那么称$B(x)$为$A(x)$在$mod$ $x^n$意义下的<strong>逆元</strong>，记作$A^{-1}(x)$</p></div><p>采用倍增思想，设$B(x)$为$\bmod x^{\lceil \frac{n}{2} \rceil}$意义下$A(x)$的逆元</p><p>经过推导，最后可以得到</p><script type="math/tex; mode=display">A^{-1}(x) \equiv 2B(x) - A(x)B^2(x) \pmod {x^n}</script><p>递归$FFT$就可以搞了,同时易知多项式有逆元的充分必要条件为常数项有逆元</p><p>$O(n \log n)$，常数约为$FFT$的$6$倍</p><a class="btn" href="http://blog.miskcoo.com/2015/05/polynomial-inverse" target="_blank" rel="noopener"><i class="fa fa-arrows-alt fa-lg fa-fw"></i>推导</a><p><br></p><h3 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a>多项式除法</h3><p>大坑待填</p><p><br></p><h3 id="多项式取模"><a href="#多项式取模" class="headerlink" title="多项式取模"></a>多项式取模</h3><p>大坑待填</p><p><br></p><h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p>给出$G(x)$，求$F(x)$，满足</p><script type="math/tex; mode=display">G(f(x)) \equiv 0 \pmod {x^n}</script><p><br></p><h3 id="多项式开方"><a href="#多项式开方" class="headerlink" title="多项式开方"></a>多项式开方</h3><p>求$B^2(x) \equiv A(x) \pmod {x^n}$</p><p>类似多项式求逆，设$B_0(x)$为$\bmod x^{\lceil \frac{n}{2} \rceil}$意义下$A(x)$的平方根</p><p>整理后得到</p><script type="math/tex; mode=display">B(x)=\frac{B_0(x)+A(x)B_0^{-1}(x)}{2} \pmod {x^n}</script><p>$O(n \log n)$</p><p><br></p><h3 id="多项式In"><a href="#多项式In" class="headerlink" title="多项式In"></a>多项式In</h3><p>求导……</p><p><br></p><h3 id="多项式exp"><a href="#多项式exp" class="headerlink" title="多项式exp"></a>多项式exp</h3><p>取对数后使用牛顿迭代法</p><p><br></p><h3 id="多项式k次幂"><a href="#多项式k次幂" class="headerlink" title="多项式k次幂"></a>多项式k次幂</h3><p>……</p><p><br></p><h3 id="多项式复合"><a href="#多项式复合" class="headerlink" title="多项式复合"></a>多项式复合</h3><p>……</p><p><br></p><h3 id="多项式多点求值与插值"><a href="#多项式多点求值与插值" class="headerlink" title="多项式多点求值与插值"></a>多项式多点求值与插值</h3><p><strong>多点求值</strong>：给出多项式$A(x)$和$n$个点$x_0, x_1, \cdots, x_{n-1}$，要求求出$A(x_0)$, $A(x_1)$, $\cdots$, $A(x_{n-1})$</p><p><strong>插值</strong>：给出n+1个点$(x_0, y_0), (x_1, y_1), \cdots, (x_n, y_n)$，求出一个$n$次多项式，使得这些点都在这个多项式上</p><p>大力搞搞……</p><p><br></p><p><strong>参考资料</strong><br><div class="note primary"><p><a href="http://blog.miskcoo.com/" target="_blank" rel="noopener">Orz Miskcoo</a>；<a href="http://blog.miskcoo.com/" target="_blank" rel="noopener">Orz Miskcoo</a>；<a href="http://www.cnblogs.com/candy99/p/6744332.html" target="_blank" rel="noopener">Orz Candy?</a></p><p><a href="http://m.blog.csdn.net/semiwaker/article/details/73251486" target="_blank" rel="noopener">总结1</a>；<a href="http://blog.csdn.net/coldef/article/details/76020530" target="_blank" rel="noopener">总结2</a></p></div></p><p><br></p><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p><br></p><h2 id="普通型生成函数"><a href="#普通型生成函数" class="headerlink" title="普通型生成函数"></a>普通型生成函数</h2><div class="note info"><p>定义序列$a_n$的普通型生成函数 (Ordinary Generating Function, OGF)，为</p><script type="math/tex; mode=display">A(x)=\sum_\limits{i=0}^{}a_ix^i</script></div><h2 id="指数型生成函数"><a href="#指数型生成函数" class="headerlink" title="指数型生成函数"></a>指数型生成函数</h2><div class="note info"><p>定义序列$a_n$的指数型生成函数 (Exponential Generating Function, EGF) ，为</p><script type="math/tex; mode=display">A(x)=\sum_\limits{i=0}^{}a_i \frac{x^i}{i!}</script></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多项式&quot;&gt;&lt;a href=&quot;#多项式&quot; class=&quot;headerlink&quot; title=&quot;多项式&quot;&gt;&lt;/a&gt;多项式&lt;/h1&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;表示&quot;&gt;&lt;a href=&quot;#表示&quot; class=&quot;headerlink&quot; title=&quot;表示&quot;&gt;&lt;/a&gt;表示&lt;/h2&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;系数表示法&lt;/strong&gt;：$F(x)=\sum\limits_{i=0}^{n}a_ix^i$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点值表示法&lt;/strong&gt;：$(x_0,y_0),(x_1,y_1),\cdots,(x_n,y_n)$&lt;/p&gt;
&lt;p&gt;对于多项式$A(x)$，称其最高项的次数为这个多项式的&lt;strong&gt;度&lt;/strong&gt;，记作$degA$&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://mmh.ac.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="http://mmh.ac.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="多项式" scheme="http://mmh.ac.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="生成函数" scheme="http://mmh.ac.cn/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>K-D Tree</title>
    <link href="http://mmh.ac.cn/2018/01/04/K-D%20Tree/"/>
    <id>http://mmh.ac.cn/2018/01/04/K-D Tree/</id>
    <published>2018-01-04T01:08:00.000Z</published>
    <updated>2018-01-11T09:19:57.231Z</updated>
    
    <content type="html"><![CDATA[<p>$K-D$  $Tree$是一种分割$k$维数据空间的数据结构，主要应用于多维空间关键数据的搜索</p><a id="more"></a><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p><br></p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>$K-D$  $Tree$中的一个节点储存了一个$K$维空间域和一个$K$维的点坐标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d:点各维坐标 mi:空间各维坐标的min mx:空间各维坐标的max c:左右儿子</span><br></pre></td></tr></table></figure><p>以下以$2-D$  $Tree$为例</p><h2 id="构树"><a href="#构树" class="headerlink" title="构树"></a>构树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmin(a,b) (a&gt;b?a=b:a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmax(a,b) (a&lt;b?a=b:a)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">abc</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ww[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> ww[x];&#125; </span><br><span class="line">&#125;a[N];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(abc x,abc y)&#123;<span class="keyword">return</span> x[D]&lt;y[D];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[x][<span class="number">0</span>]) cmin(mi[x][i],mi[c[x][<span class="number">0</span>]][i]),cmax(mx[x][i],mx[c[x][<span class="number">0</span>]][i]);</span><br><span class="line">        <span class="keyword">if</span>(c[x][<span class="number">1</span>]) cmin(mi[x][i],mi[c[x][<span class="number">1</span>]][i]),cmax(mx[x][i],mx[c[x][<span class="number">1</span>]][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span><span class="comment">//循环选取维度 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D=x;<span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    nth_element(a+l,a+m,a+r+<span class="number">1</span>);<span class="comment">//使用某一维坐标的中位数作为切分点 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) d[m][i]=mi[m][i]=mx[m][i]=a[m][i];</span><br><span class="line">    <span class="keyword">if</span>(l&lt;m) c[m][<span class="number">0</span>]=build(l,m<span class="number">-1</span>,x^<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;m) c[m][<span class="number">1</span>]=build(m+<span class="number">1</span>,r,x^<span class="number">1</span>);</span><br><span class="line">    update(m);<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="估价"><a href="#估价" class="headerlink" title="估价"></a>估价</h2><p>算出目标点到当前查询区域距离的下界或上界</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now:需估价的矩形区域 P:目标点</span></span><br><span class="line"><span class="comment">//曼哈顿最小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">    ret+=max(mi[now][i]-P[i],<span class="number">0</span>);</span><br><span class="line">    ret+=max(P[i]-mx[now][i],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//曼哈顿最大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//欧几里得最小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//欧几里得最大</span></span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//同平衡树</span></span><br><span class="line">    <span class="keyword">if</span>(!now)&#123;now=++n;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) d[now][i]=mi[now][i]=mx[now][i]=P[i];<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">int</span> tmp=P[x]&gt;=d[now][x];</span><br><span class="line">    insert(c[now][tmp],x^<span class="number">1</span>);</span><br><span class="line">    update(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(d[now][<span class="number">0</span>]-P[<span class="number">0</span>])+<span class="built_in">abs</span>(d[now][<span class="number">1</span>]-P[<span class="number">1</span>]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=Dis(x),dl[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) dl[i]=c[x][i]?getdis(c[x][i]):INF;<span class="comment">//估价函数，走较优的子树</span></span><br><span class="line">    cmin(ans,tmp);tmp=dl[<span class="number">0</span>]&gt;=dl[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(dl[tmp]&lt;ans) query(c[x][tmp]),tmp^=<span class="number">1</span>;<span class="comment">//不能更新答案直接跳过</span></span><br><span class="line">    <span class="keyword">if</span>(dl[tmp]&lt;ans) query(c[x][tmp]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$K-D$  $Tree$是一种分割$k$维数据空间的数据结构，主要应用于多维空间关键数据的搜索&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://mmh.ac.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="http://mmh.ac.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="计算几何" scheme="http://mmh.ac.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>后缀三姐妹</title>
    <link href="http://mmh.ac.cn/2017/12/26/%E5%90%8E%E7%BC%80%E4%B8%89%E5%A7%90%E5%A6%B9/"/>
    <id>http://mmh.ac.cn/2017/12/26/后缀三姐妹/</id>
    <published>2017-12-26T02:23:00.000Z</published>
    <updated>2018-01-12T01:15:46.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h1><p><br></p><div class="note info"><p>$sa(i)$：排第$i$名的后缀<br>$rank(i)$：$Suffix(i)$在所有后缀中的名次</p></div><a id="more"></a><h2 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h2><div class="note success"><p>对每个字符开始的长度为$2^k$的子字符串进行排序，求出$rank()$，当$2^k&gt;n$后，此时的$rank()$便是最后的结果<br>每一次排序利用上次两个长度为$2^{k-1}$的字符串的$rank()$作为第一、第二关键字，进行基数排序</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> l)</span></span>&#123;<span class="keyword">return</span> (r[a]==r[b])&amp;&amp;(r[a+l]==r[b+l]);&#125;<span class="comment">//比较第一、二关键字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DA</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m=<span class="number">128</span>)</span></span>&#123;<span class="comment">//n+1并人工添加一个较小的字符以避免cmp越界 </span></span><br><span class="line">    <span class="keyword">int</span> i,k,p,*x=rk,*y=rk2;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) c[i]=<span class="number">0</span>;<span class="comment">//对长度为1的字符串基数排序</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) c[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--c[x[i]]]=i;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;k&lt;&lt;=<span class="number">1</span>,m=p)&#123;<span class="comment">//max(rank())&lt;p</span></span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-k;i&lt;n;i++) y[p++]=i;<span class="comment">//不存在第二关键字的排在前面</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=k) y[p++]=sa[i]-k;<span class="comment">//利用上一次求得的SA对第二关键字排序</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) c[i]=<span class="number">0</span>;<span class="comment">//对第一关键字基数排序</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) c[x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--c[x[y[i]]]]=y[i];</span><br><span class="line">        swap(x,y),p=<span class="number">1</span>,x[sa[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++) x[sa[i]]=cmp(y,sa[i<span class="number">-1</span>],sa[i],k)?p<span class="number">-1</span>:p++;</span><br><span class="line">    &#125;<span class="comment">//rank()保存在x数组中，p=不同的字符串个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h2><p>$height(i)$：$LCP(Suffix(sa[i]),Suffix(sa[i-1]))$<br>$h(i)$：$height(rank[i])$<br>性质：</p><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>根据$h(i) \geq h(i-1)-1$逐一计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calh</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;height[rk[i++]]=k)</span><br><span class="line">        <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rk[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=height[i];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++)  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)  </span><br><span class="line">            f[i][j]=min(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=rk[a],y=rk[b];</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) swap(x,y);x++;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">log</span>(y-x+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> min(f[x][k],f[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h1 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h1><p><br></p><p>大力搞搞……</p><a class="btn" href="https://www.cnblogs.com/gaochundong/p/suffix_tree.html" target="_blank" rel="noopener"><i class="fa fa-book fa-lg fa-fw"></i>notes</a><p><br></p><h1 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h1><p><br></p><h2 id="确定性有限状态自动机"><a href="#确定性有限状态自动机" class="headerlink" title="确定性有限状态自动机"></a>确定性有限状态自动机</h2><div class="note info"><p>$DFA$由以下$5$部分组成</p><ul><li>$alpha$：字符集</li><li>$state$：状态集合</li><li>$init$：初始状态集合</li><li>$end$：终止状态集合</li><li>$trans$：状态转移函数</li></ul><p>$DFA$的功能是识别字符串<br>$SAM$本质上是一个$DFA$，可以识别$S$的所有子串</p></div><h2 id="最简状态表示"><a href="#最简状态表示" class="headerlink" title="最简状态表示"></a>最简状态表示</h2><p>现在需要把$S$建成$SAM$<br>考虑最简单的实现方式：将每个后缀插入一颗$Trie$树<br>但是这样太$naive$了，我们考虑合并状态</p><h3 id="right"><a href="#right" class="headerlink" title="right()"></a>right()</h3><p>对于$S$的一个子串$s1$，$right(s1)=s1$在$S$中所有出现的结束位置集合<br>将所有$right()$集相同的状态合并</p><h3 id="新的状态"><a href="#新的状态" class="headerlink" title="新的状态"></a>新的状态</h3><p>考虑其与原先暴力表示状态的不同</p><ul><li>代表的子串：新的状态代表的子串为右端点相同，长度递增的多种子串，记长度区间为$[min(x),max(x)]$</li><li>结论：状态的$right()$集合可以构成一个树形结构的关系，称其为$fail$树<br> 其中状态$x$在树上的父亲$fa$满足：$right(fa)\nsupseteqq right(x)$，且$|right(fa)|$最小，并有$min(x)=max(fail(x))+1$</li><li>状态数：可以证明是线性的</li><li>性质：一个子串的出现次数，就是其对应状态的$right()$集大小</li></ul><h2 id="转移函数"><a href="#转移函数" class="headerlink" title="转移函数"></a>转移函数</h2><p>$trans(x,str)$为从状态$x$读入字符串$str$后到达的状态<br>记$ST(str)=trans(init,str)$</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><h3 id="增量法"><a href="#增量法" class="headerlink" title="增量法"></a>增量法</h3><p>让新加入的子串都被状态代表，而且$trans$边能够正确转移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=a[x],np=++tot,p=last;last=np;</span><br><span class="line">    step[np]=x;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;!ch[p][c];p=fail[p]) ch[p][c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p) fail[np]=root; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(step[p]+<span class="number">1</span>==step[q]) fail[np]=q; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;step[nq]=step[p]+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq],ch[q],<span class="keyword">sizeof</span>(ch[q]));</span><br><span class="line">            fail[nq]=fail[q],fail[np]=fail[q]=nq;</span><br><span class="line">            <span class="keyword">for</span>(;ch[p][c]==q;p=fail[p]) ch[p][c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;后缀数组&quot;&gt;&lt;a href=&quot;#后缀数组&quot; class=&quot;headerlink&quot; title=&quot;后缀数组&quot;&gt;&lt;/a&gt;后缀数组&lt;/h1&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;$sa(i)$：排第$i$名的后缀&lt;br&gt;$rank(i)$：$Suffix(i)$在所有后缀中的名次&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://mmh.ac.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构" scheme="http://mmh.ac.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="字符串" scheme="http://mmh.ac.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀" scheme="http://mmh.ac.cn/tags/%E5%90%8E%E7%BC%80/"/>
    
  </entry>
  
</feed>
